# TODO: When offline, skip the install ALKiln page (except when they have no ALKiln installed). Leave button on other pages to install another version, but pressing that button should somehow show the user that they can't install a different ALKiln version when they're offline.
# TODO: Reduce number of functions into plain blocks or events. Incidentally, that will allow avoiding the complex return value for getting the html.
# TODO: Add codes to log messages.
# TODO: It's unclear that the purpose of the link below a file is to download the file.
# TODO: Use zip files and artifact folder **just once**. Use those to create in-interview variables. Since we delete the orginal zip files when we get to `show_output`, it should avoid showing future interview session visitors phantom errors.
# TODO: Add "Running offline" info callout to every page when offline
# TODO: Explore alkiln_config_vars vs. env_vars vs. cusotm_env_vars vs. dangerous_conf...
# TODO: Guard function calls for functions that are only used once with a flag. That will help us find where undefined variables are causing functions to be run repeatedly.
# TODO: There is a box shadow above accordion items that hides the gap between the accordion item and the header above it. That's slow. Some exploration has shown it's more challenging to improve than expected. Using a new element created just for that purpose isn't enough if it starts as unrendered.
# TODO: replace `raise`s with error screens
# TODO: Add more ids, including for code blocks
# TODO: Research `npm ping` for npm check instead of try/catch for connection failure
# TODO: Research check for invalid alkiln install. This seems to require testing multiple angles. `npm ls` in alkiln's folder for direct dependencies with "npm error". Maybe `npm audit signatures` maybe in .npm-global/lib/node_modules and/or maybe in alkiln's folder. Maybe `npm explain --prefix /var/www/.npm-global` (or maybe in alkiln), though I'm not sure that's the right command. To check npm itself, maybe `npm doctor --prefix /var/www/.npm-global`, though we have some stuff that already errors despite working (versions and global bin folder not in PATH).
# TODO: Consider url args to set `author_cancelled_install`, `failed_install`, etc. when starting a new interview to persist status of ALKiln package. Explore server-wide options for those.
# TODO: Only install ALKiln when no one on the server is running tests. Conversley, don't run tests until an ALKiln install on the server is finished.
# TODO: Restore background color after comfort button.
# Discuss: Show the user's username to them? Not great for recording anonymized runs through the interview, but it would put the information front and center. People have gotten confused before when exploring other user's sessions and, I believe, Projects.
# Discuss: Allow authors to run tests in other people's Playgrounds when they have permissions to open sessions and Playgrounds of other users while they are exploring those Playgrounds.
# Research: exactly how do ids on code blocks affect the cache

# NOTES
# Logs emojis: üñäÔ∏è ü§ï üí°
# format: ü§ï ALKiln ERROR ALKP00nn: (Be clear it's from ALKiln with log code prefix indicatign to devs that it's from ALKiP. Also makes it easier when first editing the log codes because it's easier to delete just the log code.)
---
metadata:
  title: |
    ALKiln in the Playground
  short title: |
    ALKiln
  description: |
    Run ALKiln tests on your server. No GitHub required.
  under: |
    See guides for writing tests in the [ALKiln documentation](https://assemblyline.suffolklitlab.org/docs/alkiln/writing/).
---
include:
  - artifacts.yml
  - validate.yml
  - generate.yml
  - headers.yml
---
features:
  css:
    - alkiln_playground.css
    - alkiln_copy_button.css
    - fidget.css
  javascript:
    - alkiln_notifications.js
    - alkiln_copy_button.js
    - dynamic_css_vars.js
    - accordion_collapse_nav.js
---
event: frustration_test
question: Uh oh
subquestion: |
  <div class="alert alert-info" markdown=1>The tests are stopping, honest. They really are doing their best. Here's yet another button. It won't do much, but it might help you feel better `(Õ°‚óµ ƒπÃØ Õ°‚óµ )`</div>
  <div id="frustration">
  ${ action_button_html("javascript:console.log(`Aaaand it also does this. Can't pull one over on you! I should know better by now.`, $(`#frustration_result`)[0]); $(`#frustration_result`)[0].style.display=`block`; $(`#frustration .btn`)[0].textContent += ` Go!`; document.body.style.backgroundColor = `rgb(` + (Math.random() * 100 + 100) + `,` + (Math.random() * 100 + 100) + `,` + (Math.random() * 100 + 100) + `)`; if ( daCheckin ) { daCheckin(); }", label="Go!", color="danger", size="md""") }
  </div>
  <div id="frustration_result" style="display: none;">Ok, it does do this stuff. That's all, though.</div>
---
comment: |
  ## Behavior for installation state:

  For now, don't worry about cross-interview persistence

  Install wait screen (source of state):
    Loading
      (reset all install-state-related vars)
      author_cancelled_install -> False
      killing_install/did_kill_install -> False
      failed_install -> False
    Installing
      No change
    Cancel
      (visual change on install waiting screen)
      author_cancelled_install -> True
      (did_kill_install is already False)
    Wait for cancellation
      No change
    Cancelled
      did_kill_install -> True
    Fail
      if not author_cancelled_install: (?)
        failed_install -> True
      or
      failed_install -> True (?)
    Succeed
      all already False
    Leaving
  
  Pick version screen:
    Loading
    Current version is questionable
      Author cancelled
      or Can't get version
      or Otherwise invalid
    Current version is fine
    Leaving
  
  Pick Project screen:
    Loading
    Current version is questionable
      Author cancelled
      or Can't get version
      or Otherwise invalid
    Current version is fine
    Leaving
---
code: |
  killing_install = False  # Default
---
mandatory: True
id: interview order
need:
  - npm_connection_msg
  - _log
  - _debug
  - get_installed_version
  - test_pid_already_terminated
  - get_test_pid
  - kill_process
  - delete_kip_session_dir
  - failed_install
  - author_cancelled_install
  - redo_after_questionable_install
  - did_kill_install
  - get_install_process_id
  - did_start_alkiln_install
  - is_first_install_page_load
code: |
  ## Test features
  # frustration_test

  # Actual code
  if not user_has_privilege( ['admin', 'developer'] ):
    ask_to_log_in

  # TODO: Refactor to avoid using `test_output` when `stopped_early` so we can
  # add a check up here for `stopped_early` and bypass everything else.
  
  if len( dangerous_config_var_names ) > 0:
    warn_about_dangerous_config_vars
  
  if redo_after_questionable_install:
    undefine( 'install_task' )
    undefine( 'ask_version' )  # Discuss: `reconsider` instead?
    # undefine_install_task = True
    # require_restart_install_timer = True
    redo_after_questionable_install = False
  
  # if undefine_install_task:
  #   undefine( 'install_task' )
  #   undefine_install_task = False

  _debug( f"""url_args: { url_args }""" )
  if url_args.get( "skip_install", False ) != "true" and version_error == "":
    ask_version

    # Kill installation if author cancelled. Avoid adding another background action
    if author_cancelled_install and not did_kill_install:
  
      # Repeat on check-in as the pid might not exist the first few times
      # Discuss: Is the da "check-in" loop enough to deal with this?
      install_pid = get_install_process_id()
      if install_pid != None:  # May not exist yet
        # Delete install pid in case author cancels future installation
        # TODO: Delete one value instead of deleting the directory üôÑ
        delete_kip_session_dir()
        # Killing halts the install_alkiln background action
        # Not sure why a blocking op here freezes the spinner on the page
        kill_process( install_pid )["ok"]
        did_kill_install = True
  
      if not did_kill_install:
        wait_for_install
      
      redo_after_questionable_install = True
  
    if npm_connection_msg == "ok" and wants_install: #

      # Discuss: Check on 'Could not get' in get_installed_version()?
      # Discuss: Check failed_install?
      
      # alkiln_current_version = "5.15.0" # testing
      # alkip_version = "1.3.1"  # testing
  
      # Show post-installation ALKiln announcements if needed
      if ( post_install_request_news != None ):
        read_the_news

      # TODO: Make sure we're showing the author the correct info about problem
      if 'Could not get' in get_installed_version():
        reconsider( ask_version )
  
      # Discuss: for some reason (at least when I switch between online and offline) we sometimes go to the install screen when going back to restart with a version number of "None". There are other shenanigans that happen when going back with `restart`. We have a lot to explore there. There are enough hiccups that it may be worth adding a warning when the author has been offline.

      # TODO: remove started_with_different_version in case of corrupted install

      # Research: May not need this check anymore
      if version_to_install: #

        if is_first_install_page_load:
          author_cancelled_install = False
          # killing_install = False  # Not yet implemented
          did_kill_install = False
          failed_install = False
          install_start = current_datetime()
          is_first_install_page_load = False
        
        if not install_task.ready(): #
          # if require_restart_install_timer: #
          #   restart_install_timer #
          wait_for_install #
        else:
          # Because of this, we MUST avoid looping here unless installing again
          is_first_install_page_load = True  # Reset
        
        if install_task.failed(): #
          failed_install = True #
          redo_after_questionable_install = True #
        else: #
          failed_install = False #
          # Avoid returning here (avoids re-triggering functions and tasks)
          wants_install = False #

    
  project_name
  tag_expression
  set_parts( title=f"ALKiln { project_name } tests" )
  set_parts( subtitle=tag_expression )

  _debug("üí° ALKiln INFO: Setting up")
  if (
    ( artifacts_folder_and_runtime_config_final_status == 'done' and artifacts_errored )
    or ( validate_feature_files_final_status == 'done' and validation_errored )
    or ( generate_constrained_random_tests_status == 'done' and generation_errored )
  ):
    setup_errored = True
  else:
    setup_errored = False  
  
  if setup_errored:
    _debug( "One of the setup steps errored" )
    # If we expect ALKiln to have the necessary scripts then
    # show the error on final screen
    # (Note: We delete the original files after showing the output
    # screen)
    show_output  # terminating screen

  _debug(f"ran_tests: { ran_tests }")
  # After a while (hours? a day?), reloading the page pseudo-triggers the task
  # again, even if it was already done. Except it never ends and the results
  # are from the old task, not the new task.
  if not ran_tests:
    if not stopped_early:
      _debug( "Running alkiln tests" )
      test_run_output

    if stopped_early and not test_pid_already_terminated:
      # We must try this repeatedly as the pid might not exist the first few times
      # Discuss: Is the da "check-in" loop enough?
      test_pid = get_test_pid()
      if test_pid != None:
        # Note: This completes the alkiln test background action too
        test_pid_already_terminated = kill_process( test_pid )["ok"]
        delete_kip_session_dir()

    # _Always_ wait for install task to be ready, otherwise when task does
    # finish da will reset some values and then rerun. E.g. `stopped_early`,
    # if True, will return to default False. Temp files will not regenerate. It
    # causes file not found errors. For example, this code would break:
    # `if stopped_early or test_run_output.ready()` Instead:
    if test_run_output.ready():
      # Don't need `.failed()`. show_output should show any failures.
      _debug(f"Test action ready. stopped_early: { stopped_early }")
      run_get_files_html
      ran_tests = True
      # Note: we remove the original files in the output screen
      show_output
    else:
      waiting_screen

  _debug(f"Skipped to the end. ran_tests: { ran_tests }; stopped_early: { stopped_early }")
  # Note: we remove the original files in the output screen
  show_output
---
code: |
  ran_tests = False # Default
---
code: |
  end_time = current_datetime()  # Default
---
code: |
  setup_outputs = []  # Default
---
code: |
  is_first_install_page_load = True
---
need:
  - root_path
  - project_name
code: |
  if get_config("s3").get("enable", False):
    sources = f"{ root_path }/playgroundsources/{ user_info().id }/{ project_name }"
  else:
    sources = f"/usr/share/docassemble/files/playgroundsources/{ user_info().id }/{ project_name }"
---
####################################
# Blockers
####################################
---
event: ask_to_log_in
id: not logged in
question: |
  You must log in to run ALKiln tests
subquestion: |
  To test a Project with ALKilnInThePlayground, you must log into the developer account that contains that Project.
buttons:
  Log into this server: signin
---
id: dangerous config var warning
if: len(dangerous_config_var_names) > 0
event: warn_about_dangerous_config_vars
question: |
  Before you start, you must change your `alkiln` config keys
subquestion: |
  In <a target="_blank" href="${ url_of( 'root', _external=True ) }/config">your docassemble server config</a>'s `alkiln` keys, you have used ${ "variable names" if len( dangerous_config_var_names ) > 1 else "a variable name" } that your operating system is already using:
  
  % if len( dangerous_config_var_names ) > 1:
  % for name in dangerous_config_var_names:
  * ${ name }
  % endfor
  % else:
  ${ dangerous_config_var_names[0] }
  % endif
  
  To fix this:
  
  % if len( dangerous_config_var_names ) > 1:
  - Change these names to something else in your config. Starting these types of variable names with something unique, like "ALKILN_", might help keep your variable names safe.
  - Update the names in your tests.
  % else:
  - Change this name to something else in your config. Starting the variable name with something unique, like "ALKILN_", might help keep your variable name safe.
  - Update the name in your tests.
  % endif
  
  When you have done that, restart this interview.
  
buttons:
  - ":undo: Restart": restart
---
####################################
# Installation
####################################
---
event: stop_install_early
code: |
  redo_after_questionable_install = True
  author_cancelled_install = True
---
code: |
  redo_after_questionable_install = False  # Default
---
code: |
  did_kill_install = False # Default
---
code: |
  failed_install = False  # Default
---
# code: |
#   undefine_install_task = False  # Default
---
if: npm_connection_msg == "ok"
code: |
  import subprocess
  import json
  
  def filter_versions_greater_or_equal(versions, minimum="0.0.0"):
    """
    Given a list of strings of versions, return a new list of
        versions at or above the given minimum version.
  
    Args:
      versions (list of str): List of semver versions.
      minimum (str): Semver version. Ignore all versions before this version.

    Returns:
      list of str: List of semver versions.
    """
    major_versions = []
    pre_versions = []
    try:
      minimum = [ int( part ) for part in minimum.split( ".", maxsplit=2 ) ]
    except Exception as err:
      raise ValueError(f"ü§ï ALKiln ERROR ALKP0001: npm version filter expected a version string in the form major.minor.patch, but got { minimum }") from err
    for version in versions:
      maj, minor, patch_and_prelease, = version.split(".", maxsplit=2)
      # If there is a prerelease attached, get rid of it in 
      # order to make the comparison
      if "-" in patch_and_prelease:
        patch, pre = patch_and_prelease.split("-", maxsplit=1)
        version_parts = [int(maj), int(minor), int(patch)]
        if version_parts >= minimum:
            pre_versions.append(version)
      else:
        version_parts = [int(maj), int(minor), int(patch_and_prelease)]
        if version_parts >= minimum:
            major_versions.append(version)
    return { "major": major_versions, "pre": pre_versions }
  
  # all versions, but not working: https://stackoverflow.com/a/41416032/14144258
  # puzzle of above: @>4.0.0 seems to get all versions @>5.0.0 seems to get none (only have a single pre-release right now). When none are found, we get err 'JSONDecodeError: Expecting value: line 1 column 1 (char 0)'
  result = subprocess.run(['npm', 'view', "@suffolklitlab/alkiln", 'versions', '--json'], check=False, capture_output=True)
  if result.returncode != 0:
    _log('ü§ï ALKiln ERROR ALKP0002: npm install errored while getting full list of ALKiln\'s versions:')
    _log(result.stderr.decode("utf-8"))
    alkiln_version_list = []
    alkiln_major_versions = []
    alkiln_prerelease_versions = []
    version_error = result.stderr.decode("utf-8")
  else:
    versions = json.loads(result.stdout.decode())
    filtered = filter_versions_greater_or_equal(reversed(versions), '5.0.0')
    alkiln_major_versions = filtered[ "major" ]
    alkiln_prerelease_versions = filtered[ "pre" ]
    alkiln_version_list = []
    version_error = ''
---
if: npm_connection_msg != "ok"
code: |
  alkiln_major_versions = []
  alkiln_prerelease_versions = []
  alkiln_version_list = []
  version_error = ""
---
id: which task but with no alkiln installed
if: |
  'Could not get' in get_installed_version() or author_cancelled_install or failed_install
need:
  - get_installed_version
  - author_cancelled_install
  - failed_install
question: |
  Install ALKiln
subquestion: |
  <div class="alert alert-warning" markdown="1">
  % if not failed_install and not author_cancelled_install:
  We are unable to find a version of ALKiln installed on your server. It looks like you either don't have ALKiln installed yet or you need to install a new version for another reason. For example, someone may have started installing a version and that installation got interrupted at a bad time. You need a new version of ALKiln.
  % elif author_cancelled_install:
  It looks like you or someone else may have stopped early when you or they were installing a new version of ALKiln. To be sure that your server has a valid version of ALKiln, we recommend you try to install again.
  % elif failed_install:
  We ran into a problem when we were trying to install ALKiln. To be sure that your server has a valid version of ALKiln, we **strongly** recommend you try to install again.
  % endif
  </div>

  ${"The server thinks you have version **" + get_installed_version() + "** of ALKiln installed on your server. " if not "Could not get" in get_installed_version() else "" }Which version of ALKiln do you want to install? The top choice is the most recent version.
fields:
  - Install a verison of ALKiln: wants_install
    datatype: yesno
  - note: |
      <div class="alert alert-warning" markdown="1">
      While ALKiln is installing you should **try very hard to avoid**:
      
      - Saving a python module
      - Pulling or uploading a package with a python module
      - Otherwise causing this server to reload, restart, or stop
      </div>
    show if: wants_install
  - Choose an ALKiln version: version_to_install
    js show if:
      val('wants_install') && !val('wants_experimental')
    choices:
      code: |
        alkiln_major_versions
  - Install an experimental version instead: wants_experimental
    datatype: yesno
    show if: wants_install
  - Experimental ALKiln version: version_to_install
    show if: wants_experimental
    choices:
      code: |
        alkiln_prerelease_versions
continue button field: ask_version
validation code: |
  if not wants_install and "Could not get" in get_installed_version():
    validation_error('You must install a version of ALKiln')
comment: |
  For when we check for an invalid ALKiln install:
  It looks like you either don't have ALKiln installed yet or you need to install a new version for another reason. For example, someone may have started installing a version and that installation got interrupted at a bad time. You need a new version of ALKiln.
---
# TODO: Test these different versions of the first page show up at the right times
id: pick which task, with offline and no alkiln installed
event: ask_version
if: |
  npm_connection_msg != "ok" and ('Could not get' in get_installed_version() or author_cancelled_install or failed_install)
need:
  - npm_connection_msg
  - get_installed_version
  - author_cancelled_install
  - failed_install
question: |
  Unable to install ALKiln
subquestion: |
  <div class="alert alert-danger">
  Unfortunately ALKilnInThePlayground is unable to install ALKiln right now. ${ npm_connection_msg }
  </div>

  It also looks like you either don't have ALKiln installed yet or perhaps a previous installation of ALKiln got messed up. For example, someone may have started installing a version and the installation got interrupted at an unfortunate time.

  You will have to run tests later.
action buttons:
  - label: Restart
    action: do_session_no_args
    icon: undo
    color: warning
---
# TODO: (For the future) Don't need `if` around news request I think. Double check.
# Discuss: Add explicit refresh button
id: which task but with prexisting version
if: |
  not 'Could not get' in get_installed_version() and not author_cancelled_install and not failed_install
need:
  - npm_connection_msg
  - author_cancelled_install
  - get_installed_version
  - failed_install
question: |
  ALKiln version
subquestion: |
  % if npm_connection_msg == "ok":
  ${ pre_install_request_news_template }
  % endif
  
  This server's current version of ALKiln is **${ get_installed_version() }**
  
  % if npm_connection_msg == "ok":
  Do you want to install a different version of ALKiln before testing? While ALKiln is installing you should **try very hard to avoid**:
      
  - Saving a python module
  - Pulling or uploading a package with a python module
  - Otherwise causing this server to reload, restart, or stop

  % else:
  Skip this page to just run the tests.
  
  <div class="alert alert-secondary">
  Note: This interview is unable to install any version of ALKiln right now. ${ npm_connection_msg }
  </div>

  You can still continue to run tests with your current version of ALKiln.
  % endif
fields:
  - Install a different verison of ALKiln: wants_install
    datatype: yesno
    show if:
      code: |
        npm_connection_msg == "ok"
  - Choose an ALKiln version: version_to_install
    js show if:
      val('wants_install') && !val('wants_experimental')
    choices:
      code: |
        alkiln_major_versions
  - Install an experimental version instead: wants_experimental
    datatype: yesno
    show if: wants_install
  - Experimental ALKiln version: version_to_install
    show if: wants_experimental
    choices:
      code: |
        alkiln_prerelease_versions
continue button field: ask_version
---
code: |
  if version_to_install != get_installed_version():
    started_with_different_version = True
  else:
    started_with_different_version = False
---
id: try to connect to npm
need:
  - try_to_connect
reconsider: True
code: |
  npm_connection_msg = try_to_connect()
---
id: check npm connection works
code: |
  import requests
  import traceback

  # TODO: try using npm ping
  def try_to_connect(url: str = "https://registry.npmjs.org/", timeout: float = 5.0):
    """
    Perform a GET request that times‚Äëout after `timeout` seconds. Return
    message about connection attempts.
    Log requests.HTTPError for 4xx/5xx status codes.

    TODO: Separate the visual connection message from the connection message
    logs since we seem to want to give different levels of details in those
    two places sometimes.

    Args:
        url (str): url to try to reach
        timeout (float): Maximum time allowed for the request

    Returns:
      str: Message about connection attempts.
    """
    try_later = "To install any ALKiln version you might have to try again later."
    we_cant_help = "The ALKiln team is unable to help with this problem."

    connection_msg = "ALKilnInThePlayground was unable to connect to the servers that store ALKiln."
  
    try:
      response = requests.get(url, timeout=timeout)
      # response.raise_for_status()  # Don't raise an error

      if response.status_code >= 400 and response.status_code < 500:
        connection_msg = f"ALKilnInThePlayground sent an incorrect request to the servers that store ALKiln and got a { response.status_code } response code. Please get in touch with the ALKiln developers."
        _log(f"ü§ï ALKiln ERROR: { connection_msg }")
        _log( traceback.format_exc() )
  
      if response.status_code >= 500 and response.status_code < 600:
        connection_msg = f"The servers that store the ALKiln package were unavailable. ALKilnInThePlayground got a { response.status_code } response code. { try_later }"
        _log(f"ü§ï ALKiln ERROR: { connection_msg }")
        _log( traceback.format_exc() )
  
      if response.ok:
        connection_msg = "ok"
  
    except requests.exceptions.ConnectionError as con_err:
      # This server isn't connected to the internet or there is some other
      #     connection problem
      # Discuss: More detailed explanations have more info, but are a possible
      #     rabbit hole for the authors:
      #     "ALKiln is stored on a third-party server that we trust, npmjs."
      connection_msg = f'ALKilnInThePlayground is unable to connect to the server where ALKiln is stored. { we_cant_help } { try_later }'
      _log(f"""ü§ï ALKiln ERROR: npmjs ConnectionError. ALKilnInThePlayground is unable to connect to the servers where ALKiln is stored. The author's docassemble server might be disconnected from the internet, npmjs' server may be unavailable, or something else may be wrong. { we_cant_help } { try_later } Stacktrace:""")
      _log( traceback.format_exc() )
  
    except requests.RequestException as req_err:
      connection_msg = 'ALKilnInThePlayground ran into a "RequestException" error when it tried to connect to the server that stores the ALKiln package. { try_later }'
      _log(f"ü§ï ALKiln ERROR: { connection_msg } Stacktrace:")
      _log( traceback.format_exc() )
  
    except Exception as general_err:
      connection_msg = f'ALKilnInThePlayground ran into a "{ type( general_err ).__name__ }" error when it tried to connect to the server that stores the ALKiln package. { try_later }'
      _log(f"ü§ï ALKiln ERROR: { connection_msg } Stacktrace:")
      _log( traceback.format_exc() )
      # Discuss clarity of an alternative:
      # _log( traceback.format_exc() )
      # _log(f"ü§ï ALKiln ERROR: { connection_msg } See the error message above.")

    return connection_msg
---
# Discuss: Should `if matches == None:` be an error path?
need:
  - da_log_more_info
code: |
  import subprocess
  import re
  
  def get_installed_version():
    """
    Returns string to print for the version number or an error message with
        'Could not get'.
        Discuss: a better way to fail. Separate the error messages from the
        failure itself.

    Returns:
        str: The version number or an error to show the user.
    """

    # https://stackoverflow.com/a/13332300
    packages = subprocess.run(['npm', 'list', '-g', '--prefix', '/var/www/.npm-global', '--depth', '0', '-p', '-l'], check=False, capture_output=True)
    # What would cause an error here?
    if packages.returncode != 0:
      _log('ü§ï ALKiln ERROR ALKP0003: getting this server\'s currently installed ALKiln version:')
      _log(f'Error code: { packages.returncode }')
      _log( packages.stderr.decode("utf-8") )
      server_version = f"Could not get this server's version of ALKiln. ALKilnInThePlayground got an error instead. { da_log_more_info }"
    else:
      pattern = re.compile(r'suffolklitlab/alkiln@(\d.*)$')
      matches = re.search(pattern, packages.stdout.decode())
      if matches == None:
        server_version = "Could not get this server's version of ALKiln. It seems to be missing. Install a version of ALKiln to continue."
      else:
        server_version = matches.group(1)
        del matches # cannot pickle error otherwise
    return server_version
---
reconsider: True
id: alkip_version
code: |
  import importlib
  
  # In an installed package:
  try:
    # In the playground, I believe this would be "playground". Haven't yet
    # found a way to get the version number of a Playground ALKiP
    alkip_version = importlib.metadata.version( current_context().package )
  
  except:
    alkip_version = 'development'  # Don't show any notifications in development environment until we work this out
  
  # alkip_version = '1.4.0'  # testing. TODO: remove
---
reconsider: True
id: alkiln_current_version
code: |
  alkiln_current_version = get_installed_version()
---
reconsider: True
id: alkiln_desired_version
code: |
  if defined('ask_version') and wants_install:
    alkiln_desired_version = version_to_install
  else:
    alkiln_desired_version = None
  _debug(f"version_to_install: {version_to_install}")
---
reconsider: True
id: dal_version
code: |
  dal_version = None  # Discuss: Is this needed? Not implemented for now.
---
reconsider: True
id: da_update_version
code: |
  da_update_version = get_config('python version')
---
reconsider: True
id: da_docker_run_version
code: |
  da_docker_run_version = get_config('system version')
---
id: live breaking news
need:
  - has_command
  - alkip_version
  - alkiln_current_version
  - alkiln_desired_version
  - dal_version
  - da_update_version
  - da_docker_run_version
  - env_vars
  - log_broad_news_exception
code: |
  import subprocess
  import os
  import re
  
  def get_the_news():
    """
    Returns the HTML string for any relevant ALKiln notifications.
  
    Note: Will use `try` a lot to avoid causing any stopping errors.

    Returns:
        str: the HTML string for any relevant ALKiln notifications.
    """
    bin_name = "alkiln-news"
    news_cmd_exists = has_command( bin_name )
    if not news_cmd_exists:
      _debug(f"üñäÔ∏è ALKiln NOTE: The '{ bin_name }' command doesn't exist in this version of ALKiln")
      return None

    _debug(f"alkip_version {alkip_version}", "console")
    _debug(f"alkiln_desired_version {alkiln_desired_version}", "console")
    _debug(f"alkiln_current_version {alkiln_current_version}", "console")
  
    news_args_ob = {
      'alkip_version': alkip_version,
      'alkiln_desired_version': alkiln_desired_version,
      'alkiln_current_version': alkiln_current_version,
      'dal_version': dal_version,
      'da_update_version': da_update_version,
      'da_docker_run_version': da_docker_run_version
    }
    news_args_strs = [f'--{ key }={ value }' for key, value in news_args_ob.items() if value]
  
    to_run = [f'/var/www/.npm-global/bin/{ bin_name }'] + news_args_strs

    # Discuss: Switch the order of these arguments?
    custom_env = dict( os.environ, **env_vars )
    returncode = None
    
    _debug('üí° ALKiln INFO: Starting ALKiln news bulletin check. Running:')
    _debug(to_run)

    try:
      news_subprocess = subprocess.run(
        to_run,
        check=False,
        capture_output=True,
        env=custom_env
      )

      _debug(f"Ran news subprocess")
  
      if news_subprocess.returncode != 0:
        news_err_msg = news_subprocess.stderr.decode('utf-8')
        _log('üñäÔ∏è ALKiln NOTE: Skipped getting news bulletin from ALKiln')
        _debug( news_err_msg )
        preprint = None
      else:
        preprint = news_subprocess.stdout.decode('utf-8')
      
      if preprint != None:
        codes = ' '.join(re.findall(r'ALK\d{4}', preprint))
        if ("ALK0278" in preprint or "ALK0279" in preprint):
          _debug(f"üí° ALKiln INFO: Looked for notifications from ALKiln. There were none. No news is probably good news. Returned code or codes: { codes }")
          preprint = None
      
        else:
          _log(f"üí° ALKiln INFO: Found ALKiln notifications. If you can't already see them, refresh your interview screen. Returned code or codes: { codes }")
  
    except Exception as news_error:
      define('broad_news_exception', news_error)
      log_broad_news_exception( news_error )
      preprint = None

    return preprint
---
code: |
  import traceback

  def log_broad_news_exception( current_error ):
    """
    Given an ALKiln notification error, log the error in the appropriate way.
        That is, if the error is not necessary only log it if debugging is
        turned on, otherwise only log it if it is useful to the author.
        We are currently unsure what the criteria of "necessary" mean.

    Args:
        current_error (error or str): An error object or error message.
    """
    log_to_debug = True
    if defined( "broad_news_exception" ):
      if str( broad_news_exception ) != str( current_error ):
        _debug(f"""str( broad_news_exception ): { str( broad_news_exception )}, str( current_error ): { str( current_error ) }""")
        # I swear this contingent was necessary, though I'm no longer sure why
        # I believe this means this is a relevant error object as opposed to a
        # message and thus that the author should know about in their log. I do
        # remember it was an edge case, but not how to trigger it again.
        log_to_debug = False
    else:
      define( "broad_news_exception", current_error )
      log_to_debug = False

    news_distributor_msg = f"üñäÔ∏è ALKiln NOTE: ALKilnInThePlayground was unable to get the ALKiln notifications that come with ALKiln v5.16.0 or above. Potentially more info:"
    if log_to_debug:
      _debug( news_distributor_msg )
      _debug("\n".join( traceback.format_exception( broad_news_exception ) ))
    else:
      _log( news_distributor_msg )
      _log("\n".join( traceback.format_exception( broad_news_exception ) ))
  
    _debug("Logged broad news exception")
---
id: news before asking to install a different version of ALKiln
need:
  - get_the_news
code: |
  # Trigger the below function only once. Consider using a task for this.
  # TODO: Research why this in particular is getting re-triggered
  if not got_pre_install_request_news:
    got_pre_install_request_news = True
    pre_install_request_news = get_the_news()
---
id: default value for got_pre_install_request_news
code: |
  got_pre_install_request_news = False
---
id: news relevant to this server and test configuration
need:
  - pre_install_request_news
template: pre_install_request_news_template
content: |
  % if pre_install_request_news != None:

  <iframe id="alkiln_notifications"></iframe>
  <div id="alkiln_broadsheet_content_data" data-broadsheet="${ encode_name( str( pre_install_request_news )) }" style="display: none;" aria-hidden="true"></div>
  
  % endif
---
id: post-install news
code: |
  post_install_request_news = get_the_news()
---
id: any relevant news after author has requested a new ALKiln version
# This template will always be visible if the author gets to this page
template: post_install_request_news_template
content: |
  <iframe id="alkiln_notifications"></iframe>
  <div id="alkiln_broadsheet_content_data" data-broadsheet="${ encode_name( str( post_install_request_news )) }" style="display: none;" aria-hidden="true"></div>
---
# TODO: Test removing this
id: default already_started_news_broadcast value
code: |
  already_started_news_broadcast = False
---
id: deliver broken news
question: |
  Before you install ALKiln version ${ alkiln_desired_version }
subquestion: |
  This might change your mind about the version you want to install.

  % if version_error == "" and post_install_request_news != None:
  ${ post_install_request_news_template }
  % endif

  If you want to pick a different version, go back a screen. If not, keep going!
continue button field: read_the_news
back button: True
back button label: Install a different version
---
# TODO: How long does this typically take? If short enough, try changing this to a foreground task
code: |
  install_task = background_action('install_alkiln', None, version=version_to_install)
---
id: make npm dir if needed
code: |
  from pathlib import Path
  try:
    npm_dir = Path( "/var/www/.npm-global" )
    npm_dir.mkdir( parents=True, exist_ok=True )
    made_npm_dir_successfully = True
  except Exception as make_npm_dir_error:
    made_npm_dir_successfully = False
    log(f"""ü§ï ALKiln ERROR: Unable to make the directory "/var/www/.npm-global".""")
---
id: install alkiln background action
event: install_alkiln
need:
  - made_npm_dir_successfully
  - did_start_alkiln_install
  - try_to_start_install
  - save_kip_session_vars
  - try_to_finish_install
  - worker_log_link
code: |
  # TODO: How do we detect if someone _else_ on the server didn't properly finish installing ALKiln and that there will be cache problems?

  # Run install only once. Needed here?
  if made_npm_dir_successfully and not did_start_alkiln_install:

    _debug(f"""üí° ALKiln INFO: Will try to install ALKiln v{ action_argument("version") }.""")
  
    # Must install with npm version, not GitHub branch as
    # we don't know a simple way to get the npm version from the
    # branch installation (to help the user install the
    # right version) or, alternatively, avoid installing anything
    # unnecessary. On GitHub, though, we hope to use the branch
    # or commit as the source of truth for our version. This
    # unfortunately means there can't be just one source of truth
    # for which version of ALKiln a test is using.
  
    install_process = None
    returncode = None
  
    did_start_alkiln_install = True
    install_attempt_result = try_to_start_install( action_argument("version") )

    if not install_attempt_result["ok"]:
      # This should trigger `.failed()` which has its own screens
      # Discuss: Move this deeper?
      raise Exception(f"ü§ï ALKiln ERROR: Something went wrong with the ALKiln installation process. Look above for more information.")

    install_process = install_attempt_result["result"]
    install_pid = install_process.pid
    max_run_time = 60 * 5  # seconds
    # Always log pid of processes so admins can terminate them manually if needed
    log(f"""üí° ALKiln INFO: Installing ALKiln v{ action_argument("version") } with process ID { install_pid }. This process will run for a maximum of { max_run_time } seconds.""" )

    # Try to store a process id to stop/terminate early if needed
    save_kip_session_vars({ "install_pid": install_pid })

    install_finish_data = try_to_finish_install( install_process, max_run_time )
    if not install_finish_data["ok"]:
      # This should trigger `.failed()` which has its own screens
      raise Exception(f"ü§ï ALKiln ERROR: Something unexpected happened when ALKilnInThePlayground tried to finish installing a version of ALKiln. Look above for more information.")
    else:
      log(f"""üí° ALKiln INFO: Finished installing ALKiln v{ action_argument("version") }!""" )
      background_response(f'üí° ALKiln INFO: Finished installing ALKiln v{ action_argument("version") }')
  
  background_response(f"ALKilnInThePlayground thinks it has already run the `install_alkiln` task. Look in your { worker_log_link } for more information.")
---
code: |
  import subprocess
  import traceback
  import os

  def try_to_start_install( desired_version ):
    """
    Return status of installation, any messages, and process.
    
    Args:
      desired_version: The version of ALKiln to try to install
    
    Returns:
      (dict):
        ok: True if succeeded, else False
        message: Additional info about what happened
        process: Value returned by `subprocess.Popen()`

    Note: The processes have a max timeout
    """
    to_install = f"@suffolklitlab/alkiln@{ desired_version }"
    ok = True
    message = "Have not yet started installing ALKiln v{ desired_version }"
    some_process = None
    clean_up_timeout = str( 60 * 3 )

    try:
    
      log(f"üí° ALKiln INFO: Starting ALKiln v{ desired_version } install process.")
      some_process = subprocess.Popen(
        ["npm", "install", "-g", to_install],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=dict(os.environ, NPM_CONFIG_PREFIX="/var/www/.npm-global"),
  
        # Even without the below, terminating the celery task won't kill the
        # subprocess, so this gives us a pid we can use to later kill the
        # process
        start_new_session=True
      )

    except Exception as alkiln_1st_install_error:
      # In the past, I too have had to uninstall and reinstall.
      # Discuss: Skip the first install? Always uninstall first?

      try:
        log("üí° ALKiln INFO: Trying to clean up the old ALKiln installation after exception.")
        some_process = subprocess.Popen(
          ["timeout", clean_up_timeout, "rm", "-r", "/var/www/.npm-global/lib/node_modules/@suffolklitlab"],
          stdout=subprocess.PIPE,
          stderr=subprocess.PIPE,
    
          # Even without the below, terminating the celery task won't kill the
          # subprocess, so this gives us a pid we can use to later kill the
          # process
          start_new_session=True
        )
      
        # Do we need an idempotency flag here?
        _debug(f"""üí° ALKiln INFO: Again trying to install ALKiln v{ desired_version }.""")
        some_process = subprocess.Popen(
          ["npm", "install", "-g", to_install],
          stdout=subprocess.PIPE,
          stderr=subprocess.PIPE,
          env=dict(os.environ, NPM_CONFIG_PREFIX="/var/www/.npm-global"),
    
          # Even without the below, terminating the celery task won't kill the
          # subprocess, so this gives us a pid we can use to later kill the
          # process
          start_new_session=True
        )

      except Exception as alkiln_2nd_un_install_error:
        ok = False
        message = f"""Error on both attempts to install ALKiln v{ desired_version }. 1st error:
  { "\n".join( traceback.format_exception( alkiln_1st_install_error ) ) }
  2nd error:
  { "\n".join( traceback.format_exception( alkiln_2nd_un_install_error ) ) }"""
        log(f"""ü§ï ALKiln ERROR ALKP0005: { message }""")

    return { "ok": ok, "message": message, "result": some_process }
---
code: |
  import subprocess
  import traceback
  
  def try_to_finish_install( install_process, max_run_time ):
    """
    Return the status, message, and output of `install_process`.
    """

    if not install_process:
      return { "ok": False, "messages": "`install_process` was a falsy value", "result": None}

    ok = True
    messages = []
    install_result = None

    install_pid = None
    returncode = None

    try:
      process_wait_start_time = current_datetime()

      install_pid = install_process.pid
      # Get `(stdout_data, stderr_data)`
      install_result = install_process.communicate( timeout=max_run_time )
      returncode = install_process.returncode

    except subprocess.TimeoutExpired:
      ok = False
      message = f"""The ALKiln installation process with the ID { install_pid } ran for over { date_difference( starting=process_wait_start_time, ending=current_datetime() ).seconds } seconds. The maximum time allowed is { max_run_time } seconds."""
      log( f"""ü§ï ALKiln ERROR: { message }""" )
      messages.append( message )

    except Exception as install_wait_error:
      ok = False
      message = f"""Error while installing ALKiln:
  { "\n".join( traceback.format_exception( install_wait_error ) ) }"""
      log(f"""ü§ï ALKiln ERROR: { message }""")
      messages.append( message )

    finally:

      # Force process to terminate if needed
      try:
        if install_process and install_pid:
          # We have to terminate this process ourselves because
          # when `.communicate` runs out of time, the system doesn't
          # complete the process itself. Low level interface.
          import os
          import signal
          # SIGTERM is not enough
          os.killpg(os.getpgid( install_pid ), signal.SIGKILL)
          install_process.wait()

        else:
          message = f"The ALKiln installation process ended and the process ID is missing. We hope there is more information elsewhere."
          log(f"""ü§ï ALKiln ERROR: { message }""")
          messages.append( message )

      except ProcessLookupError as install_already_terminated:
        # An already terminated process is a happy process
        pass
      except Exception as install_termination_error:
        ok = False
        message = f"""Error while in the middle of stopping ALKiln installation:
  { "\n".join( traceback.format_exception( install_termination_error ) ) }
  """
        log(f"""ü§ï ALKiln ERROR: { message }""")
        messages.append( message )

    # === Results ===

    if returncode == None or returncode != 0:
      message = f"""ALKiln installation had a non-zero return code of { returncode }. Not very useful. We hope there is more information elsewhere."""
      log(f"""üîé ALKiln WARNING: { message }""")
      messages.append( message )

    if install_result != None:
      stdout = install_result[0].decode('utf-8')
      stderr = install_result[1].decode('utf-8')
      if stderr:
        ok = False
        log(f"""üîé ALKiln WARNING: { stderr }""")
      install_output = "\n".join([ stdout, stderr ])
  
    log('üí° ALKiln INFO: ALKiln installation finished, for good or ill.')

    return { "ok": ok, "message": "\n".join( messages ), "result": install_output }
---
id: did_start_alkiln_install default
code: |
  did_start_alkiln_install = False  # Default
---
code: |
  author_cancelled_install = False  # Default
---
id: wait page for alkiln install
prevent going back: True
reload: True
event: wait_for_install
question: |
  One sec, installing ALKiln v${ version_to_install }
subquestion: |
  <div class="spinner-container d-flex justify-content-center">
  <div class="spinner-border" role="status">
    <span class="visually-hidden">Installing...</span>
  </div>
  </div>

  <div class="alert alert-danger" markdown="1">
  While ALKiln is installing **try very hard to avoid**:
  
  - Saving a python module
  - Pulling or uploading a package with a python module
  - Otherwise causing this server to reload, restart, or stop
  </div>
  
  This often takes less than a minute, though it can take longer if your server is slow or the servers that store ALKiln are slow.
  
  **Elapsed time: ${ str(date_difference( ending=current_datetime(), starting=install_start ).delta) }**[BR]
  (Updates about every 10 seconds depending on your server speed)

  % if author_cancelled_install:
  
  ${ "Comment: Using `daCheckin()` here should be safe because, da dev says, 'if daCheckin() is called at a time when a prior check-in request is still waiting for a response from the server, it will return without sending a check-in request'." if False else "" }
  
  <div class="alert alert-info" markdown=1>We promise, your server is working on cancelling your installation. These things can take time! Here's a button you can press if that helps, though it doesn't do much `¬Ø\_(„ÉÑ)_/¬Ø`</div>
  <div id="frustration">
  ${ action_button_html("javascript:console.log(`Well sure, it does this too. You got me.`, $(`#frustration_result`)[0]); $(`#frustration_result`)[0].style.display=`block`; document.body.style.backgroundColor = `rgb(` + (Math.random() * 100 + 100) + `,` + (Math.random() * 100 + 100) + `,` + (Math.random() * 100 + 100) + `)`; if ( daCheckin ) { daCheckin(); }", label="Hurry up!", color="danger", size="md""") }
  </div>
  <div id="frustration_result" style="display: none;">Ok, it does do a little more. That's all, though.</div>
  
  % endif

action buttons:
  - label: Cancel and try again
    action: stop_install_early
    icon: window-close
    color: danger
---
# # TODO: Explore these install_timer blocks
# code: |
#   require_restart_install_timer = False  # Default
# ---
# event: restart_install_timer
# code: |
#   install_start = current_datetime()
#   require_restart_install_timer = False
---
code: |
  install_start = current_datetime()
---
####################################
# Running tests
####################################
---
id: choose project
need:
  - version_error
  - author_cancelled_install
  - failed_install
  - da_log_more_info
  - worker_log_more_info
  - get_installed_version
prevent going back: True
question: |
  Run ALKiln tests
subquestion: |
  % if version_error != '':
  <div class="alert alert-warning" markdown=1>
  ALKilnInThePlayground was unable to get the list of versions of ALKiln from the servers that store ALKiln's code. Because of that, this tool skipped directly to this page where you can choose which tests to run. ${ da_log_more_info }
  </div>
  
  The servers that store ALKiln's code are managed by node package manager (npmjs). The <a href="https://status.npmjs.org/">npmjs status page</a> might tell you if some npmjs servers are having trouble.

  Your server says you have **ALKiln v${ get_installed_version() }** installed. You can try to use that version to run your tests.

  % elif author_cancelled_install:
  <div class="alert alert-warning" markdown=1>
  You started to install a new version of ALKiln and then stopped early. Your server thinks you have **ALKiln v${ get_installed_version() }** installed. We recommend you try to fully install a new version before running your tests.
  </div>

  % elif failed_install:
  <div class="alert alert-warning" markdown=1>
  ALKilnInThePlayground failed to install a new version of ALKiln. Your server thinks you have **ALKiln v${ get_installed_version() }** installed. We recommend you try to fully install a new version before running your tests. ${ worker_log_more_info }
  </div>

  % else:
    You will run these tests with **ALKiln v${ get_installed_version() }**.
  
  % endif
  
  <div class="alert alert-warning" markdown="1">
  While tests are running try to avoid:
  
  - Editing the Project you are testing
  - Saving a python module
  - Pulling or uploading a package with a python module
  - Otherwise causing this server to reload, restart, or stop
  </div>
  
  Choose a Project of yours that has test files. Test files are files in a package's Sources folder that end with `.feature`.
  
fields:
  - What Project do you want to test?: project_name
    input type: radio
    choices:
      code: |
        [[ proj, proj ] for proj in get_list_of_projects( user_info().id )]
  - note: |
      You can choose to run only specific tests using [tags](https://assemblyline.suffolklitlab.org/docs/components/ALKiln/writing/#tags) (like `@my_test`) in your test file and putting a [tag expression](https://assemblyline.suffolklitlab.org/docs/components/ALKiln/writing/#tags:~:text=Tag%20expression-,What%20tests%20run%3F,-%40likes_bears) in the field below.
  - I want to run all the tests: not_wants_tags
    datatype: yesno
  - "Your [tag expression](https://assemblyline.suffolklitlab.org/docs/components/ALKiln/writing/#tags:~:text=Tag%20expression-,What%20tests%20run%3F,-%40likes_bears)": tag_expression
    disable if: not_wants_tags
    # It is fine if they leave it blank. This question is for author comfort
    required: False
continue button label: '<i class="far fa-play-circle"></i> Run tests'
action buttons:
  - label: Install a new ALKiln version
    action: do_session_no_args
    color: warning
---
code: |
  from docassemble.webapp.files import SavedFile

  def get_list_of_projects(user_id):
    """
    Return the list of the Projects of a user on this server with the give ID.

    Args:
        user_id (str): id of an account on this server
  
    Returns:
        list of str: List of the user's Projects
    """
    playground = SavedFile(user_id, fix=False, section='playground')
    return playground.list_of_dirs()
---
if:
  - not_wants_tags
code: |
  tag_expression = ''
---
need:
  - tag_expression
  - project_name
code: |
  test_run_output = background_action('run_alkiln', None, tag_expression=tag_expression, project_name=project_name)
---
# Discuss: Should this be in the helpers section?
reconsider: True
id: alkiln-related config vars
code: |
  alkiln_config_vars = get_config('alkiln') or {}
---
need:
  - alkiln_config_vars
code: |
  import os
  
  os_env = os.environ.copy()
  dangerous_config_var_names = [var for var in alkiln_config_vars if var in os_env]
  # Discuss: consider creating a list that excludes the current dangerous vars. That more permissive list would allow tests to continue even though the tests wouldn't have all the config vars the author wants. Questionable.
---
# TODO: Carefully try to completely replace `env_vars` with `alkiln_config_vars` or switch their names
# TODO: Possible to use `alkiln_config_vars` in here instead of getting vars again with `temp_env_vars`?
if: len(dangerous_config_var_names) == 0
code: |
  temp_env_vars = get_config('alkiln') or {}
  temp_env_STRING_VALUES = {key: str(val) for key, val in temp_env_vars.items()}
  env_vars = temp_env_STRING_VALUES
---
id: set custom env vars
reconsider: True
need:
  - project_name
code: |
  import os

  custom_env = dict(
    os.environ,
    # Discuss: Remove this req?
    SERVER_URL=f'{url_of("root", _external=True)}',
    _ORIGIN='playground', _ALKILN_ORIGIN='playground',
    _PROJECT_NAME=project_name, _ALKILN_PROJECT_NAME=project_name,
    _USER_ID=f'{user_info().id}', _ALKILN_USER_ID=f'{user_info().id}',
    _TAGS=tag_expression,
    **env_vars
  )
---
comment: |
  alkiln_runtime folder. Inside:
  - JSON file named by the `alkiln_session_id`
      { test_pid: <pid> } (Make the file then delete it, but
      also, on start, delete any folders with PDs that have
      already been terminated.
  - (in future) runtime_config.json
  Or:
  Folder named by `alkiln_session_id` or name based on `user_id`, `project` name, and da session id containing
  - alkip_runtime_vars
  - (in future) runtime_config.json
  Or:
  Folder in Playground Project (permanent, invisible, uncommitable? or temporary?)

# TODO: Use external custom_env_vars here
id: run alkiln
event: run_alkiln
need:
  - env_vars
  - sources
  - has_started_tests
  - worker_log_link
  - save_kip_session_vars
  - root_path
# Note: .wait() will deadlock when using stdout=PIPE or stderr=PIPE and the child process generates enough output to a pipe such that it blocks waiting for the OS pipe buffer to accept more data. Use Popen.communicate() when using pipes to avoid that.
# https://docs.python.org/3/library/subprocess.html#subprocess.Popen.wait
#
# To get output out of a subprocess while it runs, potentially:
# https://www.digitaldesignjournal.com/subprocess-communicate/
# import subprocess

# cmd = ["ping", "example.com"]
# process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

# while True:
#     # Read a line from the subprocess's stdout
#     line = process.stdout.readline()
    
#     # Check if the line is empty, indicating that the subprocess has finished
#     if not line:
#         break
    
#     # Process and print the line
#     print(line, end='')

# # Wait for the subprocess to finish and get its return code
# return_code = process.wait()
# print(f"Subprocess returned with exit code: {return_code}")
code: |
  import subprocess
  import signal
  import os

  cmd_exists = has_command("alkiln-run")
  
  # When the process times out, chrome is closing, but node isn't for about another 50 seconds. That's shorter than the test, which is good, but I'm not sure why it waits so long.

  # if statement for idempotency - ensure tests are only run once
  if not has_started_tests:
    returncode = None
    test_output = None
    test_run_pid = None
  
    # Ensure that files in the 'sources' folder of all projects are
    # cached in /tmp for S3 and such server configurations so that
    # alkiln can get them there. They should be there for 2hrs at least.
    # It's not possible to just pick one project.
    # From https://github.com/SuffolkLITLab/docassemble-ALDashboard/blob/main/docassemble/ALDashboard/create_package.py#L14-L17
    SavedFile(user_info().id, fix=True, section='playgroundsources')

    sources_arg = f'--sources={ sources }'
    log(f"""üí° ALKiln INFO: sources path: { sources }""")
  
    tags = action_argument('tag_expression')
  
    # linux and `.communicate()` `timeout` is in seconds
    # 60 seconds * 60 minutes * 12 hours
    timeout_env_var_name = 'ALKILN_MAX_SECONDS_FOR_PLAYGROUND_TEST_RUN'
    max_run_time = env_vars.get(
      timeout_env_var_name,
      60 * 60 * 12
    )

    # Make sure not to pass an empty string for tags as that results in
    # a "@" with no value after it in ALKiln.
    if tags != '':
      to_run = ['/var/www/.npm-global/bin/alkiln-run', tags, sources_arg]
    else:
      to_run = ['/var/www/.npm-global/bin/alkiln-run', sources_arg]
    
    # Prepare the environment variables
    custom_env = dict(
      os.environ,
      SERVER_URL=f'{url_of("root", _external=True)}',
      _ORIGIN='playground',
      _ALKILN_ORIGIN='playground',
      _PROJECT_NAME=action_argument('project_name'),
      _ALKILN_PROJECT_NAME=action_argument('project_name'),
      _USER_ID=f'{user_info().id}',
      _ALKILN_USER_ID=f'{user_info().id}',
      _TAGS=action_argument('tag_expression'),
      # Only need these in GitHub
      REPO_URL="X",
      BRANCH_NAME="X",
      DOCASSEMBLE_DEVELOPER_API_KEY="X",
      **env_vars
    )
    
    # Ensure tests don't re-run, even (especially) if they error
    has_started_tests = True
    
    # Run the tests
    try:
      process = subprocess.Popen(
        to_run,
        start_new_session=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=custom_env,
        # Currently "/tmp" is the value da already gives for cwd (in background
        # actions only as far as we can tell), but it may change ¬Ø\_(„ÉÑ)_/¬Ø
        cwd=root_path
      )

      process_wait_start_time = current_datetime()

      # Get the process id of the subprocess
      test_run_pid = process.pid
      log(f"""üí° ALKiln INFO: Running ALKiln tests with process ID { test_run_pid }. This process will run for a maximum of { max_run_time } seconds.""" )

      # ====== Early process termination ====== #
      # Try to store a process id to stop/terminate early if needed
      save_kip_session_vars({ "test_pid": test_run_pid })

      # ====== Process outcome and output ====== #
      try:

        # Get output tuple: `(stdout_data, stderr_data)`
        # As a last resort, the processes will timeout
  
        test_output = process.communicate( timeout=max_run_time )
        returncode = process.returncode
  
      except subprocess.TimeoutExpired:
        # Example use of this exception:
        # https://github.com/SuffolkLITLab/docassemble-AssemblyLine/blob/ef5dd232b0a3557fd4b8e9185883e0ecc6a161bb/docassemble/AssemblyLine/al_document.py#L2842-L2850
        timeout_output = f'ü§ï ALKiln ERROR ALKP0006: the tests run with the ID { test_run_pid } ran for over { date_difference( starting=process_wait_start_time, ending=current_datetime() ).seconds } seconds. The maximum time allowed is { max_run_time } seconds. You can change the maximum time by adding the `{ timeout_env_var_name }` value to your config\'s `alkiln` section and giving it a different value.'
        log(timeout_output)
  
      except Exception as error:
        log('ü§ï ALKiln ERROR ALKP0010: Error while running tests:')
        log(error)

    # TODO: Remove since we removed the `timeout` command from the process?
    except subprocess.TimeoutExpired:
      # Example use of this exception:
      # https://github.com/SuffolkLITLab/docassemble-AssemblyLine/blob/ef5dd232b0a3557fd4b8e9185883e0ecc6a161bb/docassemble/AssemblyLine/al_document.py#L2842-L2850
      timeout_output = f'ü§ï ALKiln ERROR ALKP0012: the tests run with the ID { test_run_pid } ran for over { date_difference( starting=process_wait_start_time, ending=current_datetime() ).seconds } seconds. The maximum time allowed is { max_run_time } seconds. You can change the maximum time by adding the `{ timeout_env_var_name }` value to your config\'s `alkiln` section and giving it a different value.'
      log(timeout_output)
  
    except Exception as test_run_error:
      import traceback
  
      # We get here even when the sub-processes fail
      log(f"""üí° ALKiln INFO: The test subprocess completed with the returncode { returncode }:""" )
      log("\n".join( traceback.format_exception( test_run_error ) ))

      # Throw error if the process (not the tests) failed
      # Discuss: Consolidate failure messages into 1 message
      if returncode != None and returncode != 0:
        # This will cause `.failed()` to return `True`
        raise
    
    finally:
      # Always make sure subprocess and its children are terminated
      # Always create output of some kind
      
      # Force process to terminate
      # You can test this by not stringifying `alkiln` env vars and
      # including a bool value in those env vars to cause an error
      try:
        if test_run_pid != None:
          # SIGTERM is not enough
          os.killpg(os.getpgid( test_run_pid ), signal.SIGKILL)
          # We have to terminate this process ourselves because
          # when `.communicate` runs out of time, the system doesn't
          # complete the process itself. Low level interface.
          process.wait()
        else:
          log(f"""ü§ï ALKiln ERROR: The test process ended early and the process ID is missing. Get in touch with us. If you want to experiment, in the past this problem has been caused by a value in the server config under the `alkiln` key that has a non-string value. It often comes with a message similar to "expected str, bytes or os.PathLike object, not bool". To dig even deeper, check the `run_alkiln` block in the ALKilnInThePlayground repository.""")
      except ProcessLookupError as already_terminated_error:
        # An already terminated process is a happy process
        pass
      except Exception as termination_error:
        log('ü§ï ALKiln ERROR ALKP0011: Error while stopping tests:')
        log("\n".join( traceback.format_exception( termination_error ) ))
        
      # === Output ===
  
      if test_output != None:
        stdout = test_output[0].decode('utf-8')
        stderr = test_output[1].decode('utf-8')

      return_code_msg = ''
      if showifdef("returncode", "None") == None:
        # Note: The new lines below are an attempt to control visual output
        return_code_msg = f"""The test process stopped before it could finish properly
  (technically, the returncode was `None`). Check your
  { worker_log_link } and feel free to get in touch with us.\n"""
      elif showifdef("returncode", "None") != 0:
        return_code_msg = f"""The test process stopped, but it ran into 
  an error. We hope there is more information on this
  page or in your { worker_log_link }.\n"""

      # Discuss: If return code None, link to logs? Is that duplicate info?
      output_main = '\n'.join( text for text in [ return_code_msg, showifdef('timeout_output', ''), showifdef('stdout', ''), showifdef('stderr', '') ] if text )

      ## Discuss: This seems like too much to put in the logs, but if things go
      ## too badly wrong, this might be the only available info from the tests.
      # log(f"""üí° ALKiln INFO: ALKiln test run output:\n{ output_main }""" )

      background_response( f"ALKilnInThePlayground proccess id: { test_run_pid }\n\n{ output_main }" )
---
code: |
  has_started_tests = False
---
prevent going back: True
event: waiting_screen
reload: True
question: |
  Hang tight, ALKiln is running the tests
subquestion: |
  <div class="spinner-container d-flex justify-content-center">
  <div class="spinner-border" role="status">
    <span class="visually-hidden">Running tests...</span>
  </div>
  </div>

  <div class="alert alert-warning" markdown="1">
  While tests are running try to avoid:
  
  - Editing this project
  - Saving a python module
  - Pulling or uploading a package with a python module
  - Otherwise causing this server to reload, restart, or stop
  
  Otherwise, tests might fail and you may have to rerun them.
  </div>
  
  **Elapsed time: ${ str( tests_elapsed_time.delta ) }**[BR]
  (Updates about every 10 seconds depending on your server speed)

  % if stopped_early:
  
  ${ "Comment: Using `daCheckin()` here should be safe because, da dev says, 'if daCheckin() is called at a time when a prior check-in request is still waiting for a response from the server, it will return without sending a check-in request'." if False else "" }
  
  <div class="alert alert-info" markdown=1>The tests are stopping, honest. They really are doing their best. Here's yet another button. It won't do much, but it might help you feel better `(Õ°‚óµ ƒπÃØ Õ°‚óµ )`</div>
  <div id="frustration">
  ${ action_button_html("javascript:console.log(`Aaaand it also does this. Can't pull one over on you! I should know better by now.`, $(`#frustration_result`)[0]); $(`#frustration_result`)[0].style.display=`block`; $(`#frustration .btn`)[0].textContent += ` Go!`; document.body.style.backgroundColor = `rgb(` + (Math.random() * 100 + 100) + `,` + (Math.random() * 100 + 100) + `,` + (Math.random() * 100 + 100) + `)`; if ( daCheckin ) { daCheckin(); }", label="Go!", color="danger", size="md""") }
  </div>
  <div id="frustration_result" style="display: none;">Ok, it does do this stuff. That's all, though.</div>
  % endif
action buttons:
  - label: Stop tests early
    action: stop_tests_early
    icon: window-close
    color: danger
    show if: not stopped_early
comment: |
  Relevant Lenny faces
  ( ‚óµ  Õü ñ ‚óµ )
  ‰πÅ( ‚Å∞Õ° ƒπÃØ ‚Å∞Õ° ) „Ñè
  (‚äôÔπè‚äô)
  (Õ°‚Ä¢ Õü ñ Õ°‚Ä¢)
  (Õ°‚óµ ƒπÃØ Õ°‚óµ ;)
  ( Õ°¬∞ _ ñ Õ°¬∞)
  ( Õ°¬∞ƒπÃØ Õ°¬∞ )
  ( ·µíÃ¥Ã∂ ƒπÃØ ·µíÃ¥Ã∂ )
  (·µíÃ¥Ã∂Ôπè·µíÃ¥Ã∂)
  .¬∑¬∞’û(·µíÃ¥Ã∂·ØÖ·µíÃ¥Ã∂)’û¬∞¬∑.
  (oÃ¥Ã∂Ã∑·∑Ñ‚∏ù‚∏ù¬∑Ã≠ oÃ¥Ã∂Ã∑Ã•·∑Ö‚∏ù‚∏ù)
  (oÃ¥Ã∂Ã∑·∑Ñ ¬∑Ã≠ oÃ¥Ã∂Ã∑Ã•·∑Ö)
  (√≥Ôπè√≤ÔΩ°)
  (√≥_√≤ÔΩ°)
  (·µíÃ¥Ã∂Ã∑·∑ÑÔπè·µíÃ¥Ã∂Ã∑·∑Ö)
  (‚óï_‚óï)
---
event: stop_tests_early
code: |
  _debug("Event: stop_tests_early")
  stopped_early = True
---
code: |
  # Research: This flag was an attempt to prevent `stopped_early` from getting reset to `False` when the background action got re-triggered (for some as yet unclear reason) before I guarded it with a flag. It may not be effective or necessary. We're leaving it here for now to move on to other issues.
  if not defined("stopped_early"):
    stopped_early = False
---
reconsider: True
code: |
  # Deliberately explicit about the end time
  tests_elapsed_time = date_difference( ending=current_datetime(), starting=test_start_time )
---
code: |
  test_start_time = current_datetime()
---
need:
  - folder_path
code: |
  if folder_path == None:
    files_html = ""
    test_run_outcome = None
    file_problem = True
  else:
    test_data = get_files_html( folder_path )
    files_html = test_data["html"]
    test_run_outcome = test_data["outcome"]
  run_get_files_html = True
---
code: |
  file_problem = False
---
need:
  - get_top_buttons
  - get_file_html
  - get_generated_Scenarios_section
  - logs_more_info
  - no_tests_instructions
  - get_quick_view_header
  - get_scenarios_header
code: |
  import os
  
  def get_files_html( local_folder_path ):
    """
    Return html to show artifacts files and artifacts zip. Discuss: The args
        may be unnecessary complications.

    Args:
        local_folder_path (str): path of the artifacts folder

    Returns:
        dict: Props:
        - html (str or None): HTML of the files section or None
        - outcome (str or None): 'failed', 'unexpected', 'passed' or None
    """

    local_test_run_outcome = None
  
    if local_folder_path is None:
      return {"html": "", "outcome": None}
    
    html = get_top_buttons()
    
    # collect top-level names and paths.
    top_dirs = []
    top_files = []
    top_other = []
    # A bit faster than other methods, though that doesn't matter much here so far. https://stackoverflow.com/a/62478211/14144258
    with os.scandir( local_folder_path ) as scan:
      for dir_item in scan:
        _debug(f'Scanning { local_folder_path }/{ dir_item.name }')
        if dir_item.is_file():
          top_files.append(dir_item)
        elif dir_item.is_dir():
          top_dirs.append(dir_item)
        else:
          top_other.append(dir_item)

    # ====== "Root" level directories ======
    top_dirs.sort(key=lambda dir: dir.name)
  
    # ====== Add all generated tests ======
    # There should be only one directory, but this looks clean
    generation_dir_exists = False
    generation_dirs = [ dir for dir in top_dirs if '_alkiln_generated' in dir.name ]
    for dir in generation_dirs:
      generation_dir_exists = True
      html += get_generated_Scenarios_section( dir )
  
    # ====== "Root" level files section ======
  
    html += f"""
      <section id="quick_view" class="section quick_view">
        { get_quick_view_header() }
        <aside>Top-level reports, error screenshots, etc.</aside>
        <div class="output card card-body">
        """

    # Show files that are for the all the tests combined
    # This includes error screenshots
    summary_images_html = ''
    summary_other_files_html = ''
    report_html = ''
    summary_files_exist = False
    top_files.sort(key=lambda file: file.name)
    for file in top_files:
      file_html = get_file_html(name=file.name, path=file.path)

      # Non-summary files
      # Discuss: should these be summary files too? Should
      # "debug_log" be listed if "report" is missing?
      if file.name == 'debug_log.txt':
        try:
          with open(file.path, 'r') as report:
            content = report.read()
          if 'ALK0099' in content:
            local_test_run_outcome = 'failed'
          elif 'ALK0055' in content:
            local_test_run_outcome = 'unexpected'
          elif 'ALK0054' in content:
            local_test_run_outcome = 'passed'
        except Exception as debug_log_open_err:
          import traceback
          _debug(f"üñäÔ∏è ALKiln NOTE: No debug_log.txt file.")
          _debug("\n".join( traceback.format_exception( debug_log_open_err ) ))
      elif file.name == 'temp_unexpected_results_debug_log.txt':
        # Always skip this file. Don't worry, unexpected_results.txt gets added along with
        # the rest of the files
        continue

      # Summary files
      else:
        summary_files_exist = True
        if file.name.endswith('.jpg'):
          summary_images_html += file_html
        elif file.name == 'report.txt':
          report_html = file_html
        else:
          summary_other_files_html += file_html

    if summary_files_exist:
      html += f"""
          <ul class="text_files">
            {report_html}
            {summary_other_files_html}
          </ul>
          """
      if summary_images_html != '':
        html += f"""
          <hr>
          <ul class="images">
            {summary_images_html}
          </ul>
          """
    else:
      html += str( no_tests_instructions )
    
    # End summary files items
    html += '</div>\n'
    # End summary files section
    html += '</section>\n'

    # ====== Nested dirs output ======
  
    # ====== Start all Scenarios ======
    html += '<section class="section scenarios">\n'
    html += get_scenarios_header()
  
    if ( len(top_dirs) <= 0
        or ( generation_dir_exists and len(top_dirs) <= 1 )):
      _debug("0 `top_dir`s found")
      html += """
        <div class="output card card-body scenario">
          <div class="no_output">ALKiln found no Scenario files.</div>
        </div>
      """
    
    # For each Scenario
    for dir in top_dirs:

      if '_alkiln_generated' in dir.name:
        continue
  
      html += '<div class="output card card-body scenario">\n'
      html += f'<h3>Scenario: {dir.name}</h3>\n'
      
      # Get the files in that Scenario
      for sc_files_root_path, dir_names, file_names in os.walk(f'{dir.path}'):
        file_names.sort()
        
        # Discuss: organize files by type: report, error, screenshots, downloaded. Maybe by timestamp instead of by name?
        text_files_html = ''
        images_html = ''
        templates_html = ''
        other_files_html = ''
        
        if len(file_names) == 0:
          html += '<div class="no_files">ALKiln stored 0 artifact files for this Scenario.</div>'
        
        for file_name in file_names:
          abs_path = os.path.abspath(os.path.join(sc_files_root_path, file_name))
          file_html = get_file_html(name=file_name, path=abs_path)
          if file_name.endswith('.txt'):
            text_files_html += file_html
          elif file_name.endswith('.jpg'):
            # Discuss: carrousel for error screenshots section?
            # Discuss: sym link to images instead of duplicate?
            images_html += file_html
          elif file_name.endswith('.pdf') or file_name.endswith('.docx'):
            # TODO: need more flexibility for other types of downloaded files
            templates_html += file_html
          else:
            # Not sure what these'll be
            other_files_html += file_html
        
        if text_files_html != '':
          html += f'<ul class="text_files">\n{text_files_html}\n</ul>\n'
        # Downloaded pdfs and docxs
        if templates_html != '':
          html += '<hr>\n'
          html += f'<ul class="templates">\n{templates_html}\n</ul>\n'
        if images_html != '':
          html += '<hr>\n'
          # Ordered list because timing creates an order that does matter. Moreso once we have story table screenshots
          html += f'<ol class="images">\n{images_html}\n</ol>\n'
        if other_files_html != '':
          html += '<hr>\n'
          html += f'<ul class="other_files">\n{other_files_html}\n</ul>\n'
      # Ends one Scenario
      html += '</div>\n'
      
    # End all Scenarios
    html += '</section>\n'
    
    return { "html": html, "outcome": local_test_run_outcome }
---
id: top buttons
need:
  - make_and_get_artifacts_zip_downloader
code: |
  import subprocess
  
  def get_top_buttons():
    """
    Returns:
          str: the top-most functional buttons HTML for the results page
    """

    zip_html = make_and_get_artifacts_zip_downloader()

    html = f"""
      <section class="section top_buttons">
        <div class="quick_buttons top">
          { zip_html }
  
          <nav class="to_console_logs_from_top">
            <a class="non_da_internal_link btn btn-secondary" href="#console" markdown="1" type="button">:arrows-down-to-line: Jump down to the full console logs</a>
          </nav>
        </div>
      </section>
    """

    return html
---
id: zip section
need:
  - zip_name_no_ext
  - zip_name
  - root_path
  - folder_path
  - folder_name
  - da_log_more_info
code: |
  import subprocess
  
  def make_and_get_artifacts_zip_downloader():
    """
    Returns:
        str: the zip download button HTML for the artifacts folder
    """

    zip_not_found_html = f"""
        <div class="alkiln_error alert alert-warning">ALKilnInThePlayground was unable to create a zip file for the test artifacts. You might find more clues on this page. { da_log_more_info }</div>\n
      """

    if zip_name == None:
      return default_html
  
    _debug(f"""üí° ALKiln INFO: will try to get the artifacts zip from "{ folder_path }" (in "{ root_path }") and save the artifacts zip with the name "{ zip_name }".""" )

    # TODO: Remove zip_name_no_ext if possible. `zip` cmd doesn't need it.

    zipping_did_error = False
    try:
  
      # cwd controls where the expanded zip's path starts. Every folder beyond
      # the cwd location will show up in the output of expanding the zip.
      # zip_name_no_ext ex: "the_zip"
      # folder_path ex: "/tmp/the_folder"
      zip_process = subprocess.run(['zip', '-rv', zip_name_no_ext, folder_name ], cwd=root_path, check=False, capture_output=True)

      # Folder path was fine, but unable to make zip
      if zip_process.returncode != 0:
        zipping_did_error = True
        returncode = zip_process.returncode

        if returncode == 12:
          _log( f'ü§ï ALKiln ERROR: when trying to zip the artifacts folder at "{ folder_path }" in cwd "{ root_path }", the zip command was unable to find the file or directory. Return code "{ zip_process.returncode }" ("zip has nothing to do").' )
        elif returncode == 15:
          _log( f'ü§ï ALKiln ERROR: when trying to zip the artifacts folder at "{ folder_path }" in cwd "{ root_path }", the zip command was unable to create a file to write to. Return code "{ zip_process.returncode }".' )
  
        else:
          _log( f'ü§ï ALKiln ERROR ALKP0007: error running `zip` command to zip the artifacts folder at "{ folder_path }" in cwd "{ root_path }" with return code "{ zip_process.returncode }". stderr:' )
          _log( zip_process.stderr.decode( "utf-8" ))

    except FileNotFoundError as zip_process_error:
      zipping_did_error = True
      _log( f'üîé ALKiln WARNING: could not find the artifacts folder at dir "{ folder_path }" in cwd "{ root_path }":' )
      import traceback
      _log("\n".join( traceback.format_exception( zip_process_error ) ))
      
    except Exception as zip_process_error:
      zipping_did_error = True
      _log( f'ü§ï ALKiln ERROR: subprocess errored when ALKilnInThePlayground tried to zip the artifacts folder at dir "{ folder_path }" in cwd "{ root_path }":' )
      import traceback
      _log("\n".join( traceback.format_exception( zip_process_error ) ))

    if zipping_did_error:
      return zip_not_found_html
  
    zip_path = get_artifacts_zip_path()["path"]
  
    if zip_process.stdout:
      _debug(f"""üí° ALKiln INFO: saved the artifacts zip file correctly to "{ zip_path }". stdout:""")
      _debug( zip_process.stdout )

    zip_da_file = DAFile()
    zip_da_file.initialize( filename=zip_name )
    zip_da_file.copy_into( zip_path )
    zip_da_file.commit()
  
    return f"""
        <menu>{ action_button_html(zip_da_file.url_for(), label="Download all files and folders that ALKiln created", color="primary", size="md", icon="file-zipper", new_window=True, classname="zip") }</menu>
    """
---
id: no tests instructions
template: no_tests_instructions
content: |
  <div class="no_output">
    <p>ALKiln found no summary files (like report.txt). Maybe no tests ran. Here are some questions that might help find the problem.</p>
    <p>Does <a class="non_da_internal_link" href="#console">the console output at the bottom of this page</a> show that the tests ran "0 scenarios"? If so:</p>
    <ul>
      <li>Does <a class="non_da_internal_link" href="#console">that console output</a> show that ALKiln ran into an error before it could run any of your tests? If so, read those error messages and any in your logs.</li>
      <li>Does your Sources folder contain files ending in ".feature"? If not, your package has no tests to run.</li>
      <li>Look at <a class="non_da_internal_link" href="#metadata">the top of this page at the value of "Tag expression"</a>.
        <ul>
          <li>Do you have a typo in your tag expression?</li>
          <li>Does your tag expression have <a href="https://assemblyline.suffolklitlab.org/docs/components/ALKiln/writing/#tags:~:text=2%20and%203-,not%20%40wild_bear,-All%20tests%20in">the word `not` in it</a>? That tells ALKiln to skip some tests.</li>
          <li>Does your <a target="_blank" href="${url_of('root', _external=True)}/config">your docassemble server config</a> set <a href="https://assemblyline.suffolklitlab.org/docs/components/ALKiln/writing/#github-optional-inputs:~:text=ALKILN_TAG_EXPRESSION%20is%20the%20%22tag%20expression%22%20to%20use%20to%20limit%20which%20tests%20to%20run">the ALKiln environment variable <code>ALKILN_TAG_EXPRESSION</code></a>? If you need to override it you can write a new one in the tag expression field just before you run these tests.</li>
        </ul>
      </li>
    </ul>
    <p>${ logs_more_info }</p>
  </div>
---
# We plan to remove functions. This is part of the preparation.
objects:
  - sections: DAList.using( object_type=DAObject, complete_attribute="header" )
---
id: html section for generated randomized Scenarios
need:
  - get_feature_html
  - menu_download_n_copy
  - sticky_h2_header
  - root_path
  - sections
code: |
  import os
  import shutil
  import json
  
  def get_generated_Scenarios_section( dir ):
    """
    Return the HTML for the list of generated files or a missing files msg.

    Args:
        dir (str): The dir that holds the new .feature files

    Returns:
        str: the HTML for the list of generated files or a missing files msg.
    """
    gen = sections[ sections.number_gathered() ]

    # Discuss: Add "expand all" button?
    gen.heading = "New randomized tests"
    gen.id = "generated_scenarios"
  
    html = f"""
    <section id="generated" class="section generated">
      { sticky_h2_header( gen ) }
      <div class="accordion output generated">
    """

    # Will the ALKiln timestamps and counter be unique enough? Probably.
    # If we generate files in parallel we'll have to check again.
    for gen_root_path, dir_names, file_names in os.walk(f'{dir.path}'):
      file_names.sort()
      num_files = len( file_names )
      for name_i in range( 0, num_files ):
        file_name = file_names[ name_i ]
        path = os.path.abspath(os.path.join(gen_root_path, file_name))
        z_index = num_files - name_i
        html += get_feature_html( path, file_name, z_index )
  
    html += "</div>\n"  # ends generated accordions
    html += "</section>\n"  # ends generated section

    return html
---
comment: |
    # Discuss: Is the "generated files" zip file worth the trouble?
  
    gen.safe_name = very_safe_name( folder_name )
    gen.zip_name = f"{ gen.safe_name }_scenarios_generated_by_alkiln.zip"
    gen.zip_pre_path = f"{ root_path }/{ gen.zip_name }"
    
    _debug(f'üí° ALKiln INFO: ALKiln will get all the generated tests at "{ folder_path }", zip them, and try to save that zip at "{ gen.zip_pre_path }"' )
    _debug(f"""gen zip_process = subprocess.run(['zip', '-rv', { gen.zip_pre_path }, '*' ], cwd={ folder_path }, check=False, capture_output=True)""" )

    # Discuss: Folder for all tmp files would be more conceptually clear
    # f"{ very safe name }_tmp"
    # But this will make code more complex
  
    zip_process = subprocess.run([
        # If we add a timestamp to _alkiln_generated, we can use `ls` (with a
        # wildcard?) to get the actual name of the file. (Since we can't figure
        # out how to use a wildcard with `zip`)
        'zip', '-rv', gen.zip_pre_path, './_alkiln_generated'
      ],
      cwd=folder_path, check=False, capture_output=True
    )

    if zip_process.stdout:
      _debug('üí° ALKiln INFO: zipped the generated scenarios folder. stdout:')
      _debug( zip_process.stdout )

    zip_data = get_any_zip_path( gen.zip_pre_path )
    gen.zip_path = zip_data[ "path" ]
    _debug(f'gen.zip_path: { gen.zip_path }')

    # Folder path was fine, but unable to make zip
    if zip_process.returncode != 0 or zip_data["problem"] != "":
      _log( f'ü§ï ALKiln ERROR: error zipping generated scenarios at "{ folder_path }" to "{ gen.zip_path }":' )
  
    if zip_process.returncode != 0:
      _log( zip_process.stderr.decode("utf-8") )
    elif zip_data[ "problem" ] != "":
      _log( zip_data[ "problem" ] )
  
    else:
      _debug(f"""üí° ALKiln INFO: ALKiln saved the generated scenarios zip file correctly to "{ gen.zip_path }"\n gen.da_zip.initialize( filename={ gen.zip_name } )\ngen.da_zip.copy_into( { gen.zip_path } )""")
      gen.da_zip = DAFile()
      gen.da_zip.initialize( filename=gen.zip_name )
      gen.da_zip.copy_into( gen.zip_path )
      gen.da_zip.commit()

      gen.download = download_zip_button( gen.da_zip.url_for() )
      gen.menu = menu_download_n_copy( gen )
---
id: html header for root-level files
need:
  - sticky_h2_header
  - sections
code: |
  def get_quick_view_header():
    """
    Returns:
        str: the HTML for the header of the "root" level files section.
    """
    quick = sections[ sections.number_gathered() ]
    quick.heading = "Results quick view"
    quick.id = "quick_view_header"
    return sticky_h2_header( quick )
---
id: html header for ouputs of Scenarios
need:
  - sticky_h2_header
  - sections
code: |
  def get_scenarios_header():
    """
    Returns:
        str: the HTML for the header of the Scenarios outputs section.
    """
    scenarios = sections[ sections.number_gathered() ]
    scenarios.heading = "Scenarios"
    scenarios.id = "scenarios_header"
    return sticky_h2_header( scenarios )
---
id: html for one generated feature file
need:
  - very_safe_name
  - copier
  - download_file_button
  - menu_download_n_copy
  - sticky_accordion_header
  - accordion_content_for_file
code: |
  import os
    
  def get_feature_html( path, file_name, z_index ):
    """
    Return the HTML for one generated feature file
  
    Note: Code style is based on a future goal to remove functions

    Args:
        path (str): path to the feature file
        file_name (str): name of the feature file
  
    Returns:
        str: HTML for one generated feature file
    """
  
    feat = sections[ sections.number_gathered() ]
    feat.heading = file_name
    feat.id = very_safe_name( file_name )

    feat.da_file = DAFile()
    feat.da_file.initialize( filename=f"{ feat.id }.feature" )
    feat.da_file.copy_into( path )
    feat.da_file.commit()

    feat.download = download_file_button( feat.da_file.url_for() )
    feat.copier = copier
    feat.menu = menu_download_n_copy( feat )
  
    html = f"""
    <section class="accordion-item feature_files alkiln_copy" style="z-index: { z_index }">
      { sticky_accordion_header( feat ) }
      { accordion_content_for_file( feat ) }
    </section>
    """

    return html
---
id: accordion content for a copyable file
code: |
  def accordion_content_for_file( accorder ):
    """
    Args:
        accorder (DAObject): Data for the desired element. Attribs:
        - id (str)
        - da_file (DAFile)
  
    Returns:
        str: HTML for a Bootstrap accordion contents with copyable text
    """
    return f"""<div id="{ accorder.id }" class="accordion-collapse collapse" aria-labelledby="{ accorder.id }">
      <pre class="accordion-body visible_text">{ accorder.da_file.slurp(auto_decode=False).decode("utf-8") }</pre>
    </div>"""
---
id: console text html
need:
  - very_safe_name
  - copier
  - download_file_button
  - console_full_text
  - to_section_bottom_button
  - to_section_top_button
code: |
  import os
  
  def get_console_html( artifacts_name ):
    """
    Returns HTML of the tests' console output section with copyable text.

    Args:
        artifacts_name (str): Name of the artifacts folder

    Returns:
        str: HTML of the tests' console output section with copyable text.
    """

    safe_name = very_safe_name( artifacts_name )

    da_file = DAFile()
    da_file.initialize(filename=f'{ safe_name }_debug_log.txt')
    da_file.write( console_full_text.content )
    da_file.commit()

    console = sections[ sections.number_gathered() ]
    console.heading = "ALKiln console logs"
    console.id = "console_heading"
  
    console.download = download_file_button( da_file.url_for() )
    console.copier = copier
    console.menu = menu_download_n_copy( console )
  
    # Avoid abstracting navigation arrangement. Too coupled; jump functionality
    # is in the header, but also spread around the edges of the section.
    console.jump_id = "console_jump"
    console.nav = to_section_bottom_button( console.jump_id )
    console.to_top = to_section_top_button( console.jump_id )

    html = f"""
    <section id="console" class="section console_output alkiln_copy">
      <div id="{ console.jump_id }" class="jump_destination"></div>
      { sticky_h2_header( console ) }
      <pre class="visible_text">{ str( console_full_text ).strip() }</pre>
      { console.to_top }
    </section>
    """

    return html
---
# TODO: Move the headings (datetime, "Test run:", etc. to ALKiln)
id: console output for console func
need:
  - setup_output_for_the_console
  - test_run_output_for_console
template: console_full_text
content: |
  % if setup_output_for_the_console or test_run_output_for_console:
  ALKiln setup and test run console output - ${ format_date(today(), format='E, dd MMM yyyy') } ${ format_time(current_datetime(), format='hh:mm:ss a z') }
  
  % if setup_output_for_the_console:
  ${ setup_output_for_the_console }
  
  %endif
  Test run:
  ${ test_run_output_for_console }
  % endif

---
id: non-feature files
# TODO: do something safer with uncategorized files
# TODO: move this up closer to the rest of the file html code
need:
  - space_to_underscore
code: |
  def get_file_html(name='', path=''):
    """
    Args:
        name (str): Name of the file.
        path (str): Path to the file.

    Returns:
        str: HTML for one file
    """
    # Show a DAFile for each file
    da_file = DAFile()
    da_file.initialize(filename=f'{space_to_underscore(name)}')
    da_file.copy_into( path )
    da_file.commit()
    
    if name.endswith('.txt'):
      html = f'<li class="text_file">\n{name} (<a target="_blank" href="{da_file.url_for()}">tap to see raw text<i class="fas fa-external-link"></i></a>)\n</li>\n'
    else:
      # Assumes a file that can be shown with a thumbnail image
      da_file.set_alt_text(f'The thumbnail image for {name}.')
      html = f'<li class="thumbnail">\n'
      html += f'<span><span>{name}</span> '
      html += f'(<a target="_blank" href="{da_file.url_for()}">tap to see file <i class="fas fa-external-link"></i></a>)'
      html += f'</span>\n'
      html += f'<div><a target="_blank" href="{da_file.url_for()}">{da_file}</a></div>\n'
      html += f'</li>\n'
    
    return html
---
id: html elements to copy to clipboard
code: |
  copier = """<div class="copy_functionality functional_button_container">
    <!-- Can't control textarea styles, esp word-wrap -->
    <textarea readonly aria-hidden="true" class="to_copy"></textarea>
  
    <button class="btn btn-secondary copy_button" type="button">
      <i class="far fa-copy"></i>
      <div class="statuses">
        <span class="copy_default">Copy</span>
        <span class="copy_done">Copied!</span>
        <span class="copy_cancelled">Cancelled copy</span>
      </div>
    </button>
  </div>"""
---
# TODO: Move to files helper section
id: remove/delete files
need:
  - folder_path
  - get_artifacts_zip_path
code: |
  # TODO: Ensure this block runs regardless of the outcome just in case it
  # can manage to clean something up. Avoid erroring. These steps aren't
  # crucial.

  _debug("Removing files and folders", "console")
  
  zip_path = get_artifacts_zip_path()["path"]
  
  import os
  try:
    os.remove( zip_path )
  except Exception as error:
    _log(f'üñäÔ∏è ALKiln NOTE ALKP0008: skipped removing old "{ zip_path }".')
    _debug(error)
  
  import shutil
  try:
    shutil.rmtree( folder_path )
  except Exception as error:
    _log(f'üñäÔ∏è ALKiln NOTE ALKP0009: skipped removing "{ folder_path }".')
    _debug(error)

  # TODO: Research whether we're deleting the connections of all server devs
  # https://stackoverflow.com/a/32949415/14144258
  import glob
  try:
    # Remove leftover puppeteer stuff if it exists (e.g. if the user
    # stopped the tests early)
    # https://github.com/puppeteer/puppeteer/issues/6414
    sub_folders_list = glob.glob('tmp/puppeteer_dev_chrome_profile*')
    for sub_folder in sub_folders_list:
      shutil.rmtree(sub_folder)
  except Exception as error:
    _debug(f'üñäÔ∏è ALKiln NOTE: skipped removing puppeteer leftovers. Maybe there were none. Message:')
    _debug(error)
  
  remove_tmp_files = True
---
need:
  - root_path
  - alkiln_session_id
  - format_error
id: remove alkip session folder
code: |
  def delete_kip_session_dir():
    """
    Try to remove ALKiP runtime session folder.
    Returns:
      (dict):
        ok (bool): False if there was an error. Else True.
        message (str): Any message about the operation.
    """
    import shutil
  
    try:
      # Remove ALKiP runtime vars file
      shutil.rmtree(f"{ root_path }/{ alkiln_session_id }")
  
    except Exception as delete_session_dir_error:
      message1 = f'üñäÔ∏è ALKiln NOTE: skipped removing "{ root_path }/{ alkiln_session_id }".'
      message2 = format_error( delete_session_dir_error )
      _log( message1 )
      _debug( message2 )
      return { "ok": False, "message": f"{ message1 }\n{ message2 }" }
  
    return { "ok": False, "message": "" } 
---
code: |
  def format_error( error ):
    return "\n".join(traceback.format_exception( error ))
---
event: show_output
need:
  - logs_more_info
  - test_run_outcome_template
  - metadata_template
  - artifacts_errored
  - file_problem
  - config_path
  - config_path_problem
  - folder_path
  - folder_path_problem
  - test_output_template
prevent going back: True
question: |
  ALKiln output
subquestion: |
  <div id="alkiln_test_output">

  ${ test_run_outcome_template }

  ${ metadata_template }

  % if artifacts_errored or validation_errored or generation_errored:
  ${ setup_error_html }
  % endif
  
  % if file_problem:
  <div class="alert alert-danger" markdown="1">
  % if config_path is None:
  ${ config_path_problem }
  % endif

  % if folder_path is None:
  ${ folder_path_problem }
  % endif

  % if get_artifacts_zip_path()["path"] is None:
  ${ get_artifacts_zip_path()["problem"] }
  % endif

  This test run did not create any files. ${ logs_more_info }
  </div>

  % else:
  ${ files_html }
  % endif

  ${ test_output_template }
  </div>

  ${ "" if remove_tmp_files else "" }
# Keep exit button to give the page the #daform selector as da bases some styles on that selector
buttons:
  - Exit: exit
action buttons:
  - label: Run new tests
    action: do_skip_install_session
    color: warning
  - label: Install a new ALKiln version
    action: do_session_no_args
    color: warning
---
event: do_skip_install_session
code: |
  # Unable to pass kwarg `url` to 'new_session'
  url_args["skip_install"] = "true"
  command('new_session')
---
event: do_session_no_args
code: |
  # Unable to pass kwarg `url` to 'new_session'
  url_args["skip_install"] = "false"
  command('new_session')
  # Warning: `command('exit', url=interview_url())` Gets "Unable to locate..."
---
code: |
  test_run_outcome = None
---
# Discuss: Add ALKiP-sourced message about updating ALKiln
# Discuss: add a test count‚Äîpassed/failed out of total
template: test_run_outcome_template
content: |
  % if test_run_outcome == 'failed':
  <header class="tests_failed alert alert-danger" style="max-height: unset;">
  <h2 style="margin: 0;">ü§ï Sorry, some tests failed</h2>
  </header>
  % elif test_run_outcome == 'unexpected':
  <header class="tests_unexpected alert alert-warning" style="max-height: unset;">
  <h2>üåÄ Hmm, something unexpected happened</h2>
  <p style="margin: 0;">
  This one's a toughie. We do not have ways to deal with this kind of problem yet. There might be more information below.
  </p>
  </header>
  % elif test_run_outcome == 'passed':
  <header class="tests_passed alert alert-info" style="max-height: unset;">
  <h2 style="margin: 0;">üí° Tests finished, none failed</h2>
  </header>
  % elif stopped_early:
  <header class="tests_stopped_early alert alert-warning" style="max-height: unset;">
    <h2 style="margin: 0;">üíî Stopped the tests early</h2>
  </header>
  % endif

  % if stopped_early:
  % if test_run_outcome is None:
  <aside class="alert alert-warning" markdown="1">
  Warning: You stopped the tests early. Below is the information the tests collected so far.
  </aside>
  % else:
  <aside class="alert alert-info" markdown="1">
  You tried to stop the tests early, but the tests were already done.
  </aside>
  % endif
  % elif test_run_outcome is None:
  <header class="tests_unexpected alert alert-warning" style="max-height: unset;">
  <h2>üåÄ Hmm, something unexpected happened</h2>
  <p style="margin: 0;">
  This one's a toughie. We do not have ways to deal with this kind of problem yet. There might be more information below.
  </p>
  </header>
  % endif
---
# Discuss: If we've thoroughly dealt with the final output page regeneration
# bug, add date/time of test run? Is the info in the console output enough?
template: metadata_template
content: |
  <section id="metadata" class="section metadata">

    <ddl class="container">
      <div class="version row justify-content-between">
        <dt class="col-6">ALKiln version</dt>
        <dd class="col-6">${ get_installed_version() }</dd>
      </div>
      <div class="version row justify-content-between">
        <dt class="col-6">ALKilnInThePlayground version</dt>
        <dd class="col-6">${ alkip_version }</dd>
      </div>

      <div id="tag_expression" class="tags row justify-content-between">
        <dt class="col-6"><a href="https://assemblyline.suffolklitlab.org/docs/components/ALKiln/writing/#tags:~:text=Tag%20expression-,What%20tests%20run%3F,-%40likes_bears">Tag expression</a></dt>
        <dd class="col-6">${ tag_expression or "No tag expression" }</dd>
      </div>
  
      % if defined('test_start_time'):
      <div class="elapsed_time row justify-content-between">
        <dt class="col-6">Elapsed time</dt>
        <dd class="col-6">${ str(date_difference( ending=end_time, starting=test_start_time ).delta) }</dd>
      </div>
      % endif
    </dl>
    
  </section>
---
need:
  - setup_output_for_the_console
  - test_run_output_for_console
  - folder_name
  - get_console_html
template: test_output_template
content: |
  ${ get_console_html( folder_name ) }
---
template: setup_output_for_the_console
content: |
  % if defined('setup_outputs') and len(setup_outputs) > 0:
  
  Artifacts folder, validation, and randomized test generation:
  % for setup_output in setup_outputs:
  ${ setup_output }
  % endfor
  
  % endif
---
template: test_run_output_for_console
need:
  - worker_log_more_info
content: |
  % if not defined('test_run_output'):
  Tests did not run. More information should be above.
  ${ worker_log_more_info } If not, please get in touch with the ALKiln developers.
  % elif test_run_output.ready() and (test_run_output.get() is None or test_run_output.get() == 'None'):
  There is no console output for the tests that ran. ${ worker_log_more_info }
  % elif test_run_output.ready():
  ${ test_run_output.get() }
  % else:
  Sorry, ALKilnInThePlayground is unable to get the console logs.
  % endif
---
template: setup_error_html
need:
  - logs_more_info
content: |
  <div class="setup_error alert alert-danger">
  <p>Test setup errored. Here are examples of why this can happen:</p>
  <ul>
  <li>Invalid ".feature" files</li>
  <li>Invalid constrained randomized tests ".feature" files</li>
  <li>An internal ALKiln error.</li>
  </ul>
  </br>
  <p>You might see console output below. ${ logs_more_info }</p>
  </div>
---
# Processes
---
id: terminate any subprocess with an id
code: |
  def kill_process( process_id ):
    """
    Return True if we did terminate the process identified by process_id.

    Args:
      process_id (int): ID of a process running on the server.

    Returns:
      (dict):
        ok (bool): True if did terminate process. Otherwise, False.
        message (str): Information. If failed, text of what went wrong.
    """
    import os
    import signal
    import traceback

    try:
      # SIGTERM is not enough
      os.killpg(os.getpgid( process_id ), signal.SIGKILL)
    except Exception as termination_error:
      message = f"""Skipping terminating { process_id }. The process might already be terminated.\n{ "\n".join(traceback.format_exception( termination_error )) }"""
      _debug( f"""üñäÔ∏è ALKiln NOTE: { message }""" )
      return { "ok": False, "message": message  }
  
    _debug(f"""üí° ALKiln INFO: terminated process with id { process_id }""")
    return { "ok": True, "message": ""  }
---
code: |
  test_pid_already_terminated = False
---
# Files
---
id: save any alkip session var
need:
  - kip_dir
  - kip_vars_path
code: |
  from pathlib import Path
  import json
  import traceback
  
  def save_kip_session_vars( new_data ):
    """
    Args:
      new_data (dict(any)): Key/value pairs to add to or replace the session vars

    Returns:
      (dict):
        ok (bool): True if succeeded, False if failed
        message (str): Information. If failed, text of what went wrong.
    """
    session_dir = Path( kip_dir )
    session_dir.mkdir( parents=True, exist_ok=True )

    file_already_exists = False
    session_vars_str = None
    session_filepath = Path( kip_vars_path )

    try:
      session_vars_str = session_filepath.read_text()
      file_already_exists = True

    except FileNotFoundError as kip_vars_notfound_error:
      try:
        session_filepath.write_text(json.dumps( new_data ))

      except Exception as write_new_kip_vars_error:
        message = f"""Skipped writing new ALKiP vars json file: {"\n".join( traceback.format_exception( write_new_kip_vars_error ) )}"""
        log(f"""üñäÔ∏è ALKiln NOTE: { message }""")
        return { "ok": False, "message": message }

    except Exception as kip_vars_read_error:
      message = f"""Skipped reading ALKiP vars json file: {"\n".join( traceback.format_exception( kip_vars_read_error ) )}"""
      log(f"""üñäÔ∏è ALKiln NOTE: { message }""")
      return { "ok": False, "message": message }

    if file_already_exists:
      try:
        kip_session_json = json.loads( session_vars_str )
        kip_session_json.update( new_data )
        session_filepath.write_text(json.dumps( kip_session_json ))

      except Exception as kip_vars_edit_error:
        message = f"""Skipped editing ALKiP vars json file: {"\n".join( traceback.format_exception( kip_vars_edit_error ) )}"""
        log(f"""üñäÔ∏è ALKiln NOTE: { message }""")
        return { "ok": False, "message": message }
  
    return { "ok": True, "message": "" }
---
id: set runtime config vars
need:
  - get_config_path
code: |
  def set_runtime_config_vals( vars_to_set ):
    """
    Set or overwrite values in the alkiln runtime config as
        json. Return info about what happened. Discuss: Return
        all config vars?

    Args:
      vars_to_set (dict): Keys are var names, value are values
          for those keys. Must be json-ifyable.

    Returns:
      (dict):
        - ok (bool): True if succeeded, False if failed
        - message (str): Information. If failed, text of what went wrong.
    """
    import os
    import json
    import traceback

    message = ""

    # Try to read the config vars
    config_path_result = get_config_path()
    if not config_path_result["ok"]:
      return { "ok": False, "message": config_path_result["message"] }

    local_config_path = config_path_result["result"]

    config_vars = get_json_from_file( local_config_path )
    if not config_vars["ok"]:
      return { "ok": False, "message": config_vars.message }

    # Try to set the config vars
    for key, value in vars_to_set.items():
      if key in config_vars:
        _debug(f"""The key `{ key }` already exists in the runtime_config.json. ALKiP will overwrite it.""")
  
      try:
        config_vars[ key ] = value
      except Exception as set_config_err:
        message += f"""Error adding a runtime config json value called `{ key }`. Will continue to try to set more values. Error message:\n{ "\n".join(traceback.format_exception( set_config_err )) }\n"""
        _log(f"""ü§ï ALKiln ERROR ALKP0014: { message }""")

    # Try to save the new vars
    with open( local_config_path, 'w', encoding='utf-8') as config_file:
      try:
        json.dump(config_vars, config_file, ensure_ascii=False, indent=2)
      except Exception as config_dump_error:
        message = f"""Error dumping json to config file at "{ local_config_path }":\n{ "\n".join(traceback.format_exception( config_dump_error )) }"""
        _log(f"""ü§ï ALKiln ERROR ALKP0016: { message }""")
        return { "ok": False, "message": message }
  
    return { "ok": True, "message": message }
---
need:
  - root_path
  - kip_session_filename
  - alkiln_session_id
  - get_one_json_file_var
code: |
  def get_test_pid():
    """
    Returns:
        (int|None): The process id or None if we couldn't get the id.
    """
    kip_filepath = f"{ root_path }/{ alkiln_session_id }/{ kip_session_filename }"
    test_pid = get_one_json_file_var( kip_filepath, "test_pid" )["result"]
    _debug(f"""test_pid: { test_pid }""")
    return test_pid
---
need:
  - root_path
  - kip_session_filename
  - alkiln_session_id
  - get_one_json_file_var
code: |
  def get_install_process_id():
    """
    Returns:
        (int|None): The process id or None if we couldn't get the id.
    """
    kip_filepath = f"{ root_path }/{ alkiln_session_id }/{ kip_session_filename }"
    install_pid = get_one_json_file_var( kip_filepath, "install_pid" )["result"]
    _debug(f"""install_pid: { install_pid }""")
    return install_pid
---
id: one kip session var
need:
  - get_json_from_file
code: |
  def get_one_json_file_var( filepath, dict_key ):
    """
    Returns value of potential runtime config value named
        `dict_key` along with information about what happened.

    Args:
        dict_key (str): Key of value to get from runtime config

    Returns:
        (dict):
            ok (bool): True if found the value, else false
            message (str): Info about what happened (none yet)
            result (any): Config value of the given key or None
    """
    json_data = get_json_from_file( filepath )
    if not json_data["ok"]:
      return {"ok": False, "message": "Unable to find find the json file", "result": None }

    if not dict_key in json_data["result"]:
      return {"ok": False, "message": f"""üñäÔ∏è ALKiln NOTE: Unable to find `{ dict_key }` in the json file""", "result": None }

    return {
      "ok": True, "message": f"""üí° ALKiln INFO: Found the value for { dict_key }""",
      "result": json_data["result"][ dict_key ]
    }
  
---
id: one runtime config val
need:
  - get_json_from_file
code: |
  def get_one_runtime_config_val( config_key ):
    """
    Returns value of potential runtime config key named
        `config_key` along with information about what happened.

    Args:
        config_key (str): Key of value to get from runtime config

    Returns:
        (dict):
            ok (bool): True if found the value, else false
            message (str): Info about what happened (none yet)
            result (any): Config value of the given key or None
    """
    config_path_result = get_config_path()
    if not config_path_result["ok"]:
      return { "ok": False, "message": not config_path_result["message"], "result": result }

    local_config_path = config_path_result["result"]
    runtime_vals_data = get_json_from_file( local_config_path )
    if not runtime_vals_data["ok"]:
      return {"ok": False, "message": "Could not find the runtiem config", "result": None }

    if not config_key in runtime_vals_data["result"]:
      return {"ok": False, "message": "Could not find this key in the runtime config", "result": None }

    return {
      "ok": True, "message": "Found the value",
      "result": runtime_vals_data["result"][ config_key ]
    }
---
id: get config vals or ensure they're created
need:
  - get_config_path
code: |
  def get_json_from_file( json_filepath ):
    """
    Get values from the alkiln runtime config as json or, if 
        they don't yet exist, make that json. Return info about
        what happened.

    Returns:
      (dict):
        ok (bool): True if succeeded, False if failed
        message (str): If failed, text of what went wrong
        result (dict): The json
    """
    import os
    import json
    import traceback

    message = ""
    result = {}

    # config_path_result = get_config_path()
    # if not config_path_result["ok"]:
    #   return { "ok": False, "message": not config_path_result["message"], "result": result }
    # local_config_path = config_path_result["result"]

    try:
      with open( json_filepath, 'r', encoding='utf-8') as json_file:
        try:
          result = json.load( json_file )
      
        except Exception as json_load_error:
          message = f"""Error loading json from file at "{ json_filepath }":\n{ "\n".join(traceback.format_exception( json_load_error )) }"""
          _log(f"""üîé ALKiln WARNING ALKP0013: { message }""")
          return {
            "ok": False, "message": message, "result": result
          }
    except Exception as json_open_error:
      message = f"""Skipped opening json file at "{ json_filepath }":\n{ "\n".join(traceback.format_exception( json_open_error )) }"""
      _debug(f"""üñäÔ∏è ALKiln NOTE: { message }""")
      return {
        "ok": False, "message": message, "result": result
      }
  
    return { "ok": True, "message": message, "result": result }
---
reconsider: True
need:
  - get_config_path
  # - get_existing_path
code: |
  """
  Return the runtime_config.json path or, if it doesn't yet exist, None
  """
  # temp_config_path = get_existing_path( "runtime_config.json" )
  # if temp_config_path is None:
  #   config_path_problem = 'No "runtime_config.json" file exists.'
  #   _log(f'ü§ï ALKiln ERROR: { config_path_problem }')
  # config_path = temp_config_path
  config_path = get_config_path()["result"]
---
need:
  - get_existing_path
code: |
  def get_config_path():
    """
    Return the runtime_config.json path or, if it doesn't yet exist, None
    """
    ok = True
    message = ""
    result = get_existing_path( "runtime_config.json" )
  
    if result is None:
      ok = False
      message = 'No "runtime_config.json" file exists.'
      _log(f'üîé ALKiln WARNING: { message }')
    return { "ok": ok, "message": message, "result": result }
---
id: default config_path_problem
code: |
  config_path_problem = ''  # Default
---
# We get the folder_path by using ALKiln's runtime_config.json
# folder_path tries different locations till it finds the real one in order to stay compatibile with old ALKiln versions. See `get_existing_path()` notes. We use `folder_path` to get the artifacts folder to make zip names, zips, and to eventually delete the folder.
id: artifacts paths and names
need:
  - config_path
  - get_existing_path
code: |
  import os
  import traceback
  
  if config_path is None:
    folder_temp_name = 'no config'

  else:
    with open( config_path ) as config_file:

      try:
        folder_temp_name = json.load( config_file ).get('artifacts_path', 'no json value')
  
      except Exception as config_load_error:
        folder_temp_name = 'json load error'
        folder_path_problem = f"""Unable to get test results files. Unable to load JSON from the ALKiln runtime_config.json file at "{ config_path }":\n{"\n".join( traceback.format_exception( config_load_error ) )}"""
        _log(f'ü§ï ALKiln ERROR ALKP0014: { folder_path_problem }')
        _debug( config_file )
  
    if folder_temp_name == 'no json value':
      folder_path_problem = """The ALKiln runtime_config.json file at "{ config_path }" has no "artifacts_path" value."""
      _log(f'ü§ï ALKiln ERROR ALKP0015: { folder_path_problem }')

    folder_temp_path = get_existing_path( dir_name=folder_temp_name )
  
  if folder_temp_path is None:
    folder_path_problem = f'Unable to find artifacts folder called "{ folder_temp_name }".'
    root_path = None
    folder_name = None
    folder_path = None
  else:
    root_path = os.path.dirname( folder_temp_path )
    folder_name = os.path.basename( folder_temp_path )
    folder_path = folder_temp_path
  
  import os
  cwd = os.getcwd()
  _debug(f"""cwd: { cwd }, root_path: { root_path }, folder_name: { folder_name }, folder_path: { folder_path }""")
---
id: default folder_path_problem
code: |
  folder_path_problem = ""  # Default
---
# Need zip_name_no_ext to save the new zip file name without ".zip"
# Might be able to get rid of this.
need:
  - very_safe_name
  - folder_name
code: |
  if folder_name is None:
    zip_name_no_ext = None
  else:
    zip_name_no_ext = very_safe_name( folder_name )
---
# Need zip_name to avoid duplicating adding ".zip" to get
# correct zip_path value and to name zip file.
need:
  - zip_name_no_ext
code: |
  if zip_name_no_ext is None:
    zip_name = None
  else:
    zip_name = f"{ zip_name_no_ext }.zip"
---
need:
  - zip_name
code: |
  def get_artifacts_zip_path():
    """
    Confirm the existence of the artifacts folder zip file and get its true
        name. Alternatively, explain what went wrong.
  
    Example use: Put contents into the DAFile once the zip is stored wherever
        it is stored.

    Returns:
        dict: Props:
        - path (str): The full zip file path or None.
        - problem (str): Explanation of what went wrong or empty str.
    """
    zip_path_problem = ''
    if zip_name is None:
      zip_path_problem = f"""The zip file doesn't exist right now. Did the tests run? There might be more information elsewhere on this page."""
      _log(f'ü§ï ALKiln ERROR: { zip_path_problem }')
      zip_path = None
    else:
      zip_path = get_existing_path( file_name=zip_name )
      if zip_path is None:
        zip_path_problem = f'When looking for the artifacts zip file, unable to find a file called "{ zip_name }".'
        _log(f'ü§ï ALKiln ERROR: { zip_path_problem }')
  
    return { "path": zip_path, "problem": zip_path_problem }
---
code: |
  def get_any_zip_path( _zip_name ):
    """
    Confirm the existence of any zip file and get its true name.
        Alternatively, explain what went wrong.
  
    Args:
        _zip_name (str): Name of zip file

    Returns:
        dict: Props:
        - path (str): The full zip file path or None.
        - problem (str): Explanation of what went wrong or empty str.
    """
    a_zip_path_problem = ""
    a_zip_path = get_existing_path( file_name=_zip_name )
    if a_zip_path is None:
      a_zip_path_problem = f'Unable to find a file called "{ _zip_name }".'
      _log(f'ü§ï ALKiln ERROR: { a_zip_path_problem }')
    return { "path": a_zip_path, "problem": a_zip_path_problem }
---
# Older versions of ALKiln's config named relative paths
# Newer versions have absolute paths
code: |
  def get_existing_path( dir_name=None, file_name=None ):
    """
    Given one of `dir_name` or `file_name`, look for the item in the file
        system. If found, return its full path. Otherwise return None.

    Rationale: Older versions of ALKiln's config named relative paths. Newer
        versions have absolute paths. We are attempting to support both.
  
    Args:
        (optional) dir_name (str): Name or path of dir to look for
        (optional) file_name (str): Name or path of file to look for

    Returns:
        str or None: A full path or None
    """
    if dir_name != None:
      return get_existing_dir_path( dir_name )
    if file_name != None:
      return get_existing_file_path( file_name )
    _debug("üñäÔ∏è ALKiln NOTE: `get_existing_path` got no valid arguments. All arguments were None.")
    return None
---
need:
  - root_path
code: |
  import os
  
  def get_existing_dir_path( dir_name ):
    """
    Return the path of the requested directory. Try to find it using different
    root paths to be backwards compatible with old versions of ALKiln. If it
    doesn't exist at any of those locations, return None.
  
    Args:
        dir_name (str): Name or path of dir to look for

    Returns:
        str or None: A full path or None
    """
    # if "/tmp/the_dir"
    if os.path.exists( dir_name ):
      return dir_name
  
    # if "the_dir"
    if os.path.exists(f'{ root_path }/{ dir_name }'):
      return f'{ root_path }/{ dir_name }'

    # if "the_dir" and root_path broken, make a last ditch effort
    if os.path.exists(f'/tmp/{ dir_name }'):
      return f'/tmp/{ dir_name }'

    _log(f'üñäÔ∏è ALKiln NOTE: Found no "{ dir_name }", "{ root_path }/{ dir_name }", or "/tmp/{ dir_name }" directory')
    return None
---
need:
  - root_path
code: |
  import os
  
  def get_existing_file_path( file_name ):
    """
    Return the path of the requested file. Try to find it using different
    root paths to be backwards compatible with old versions of ALKiln. If it
    doesn't exist at any of those locations, return None.
  
    Args:
        file_name (str): Name or path of file to look for

    Returns:
        str or None: A full path or None
    """
  
    if os.path.isfile( file_name ):
      return file_name
    if os.path.isfile(f'{ root_path }/{ file_name }'):
      return f'{ root_path }/{ file_name }'
    if os.path.isfile(f'/tmp/{ file_name }'):
      return f'/tmp/{ file_name }'
  
    _log(f'üñäÔ∏è ALKiln NOTE: Found no "{ file_name }", "{ root_path }/{ file_name }", or "/tmp/{ file_name }" file')
    return None
---
# Buttons
---
need:
  - action_button_html
code: |
  def download_file_button( url ):
    """
    Return the HTML to download a file.
  
    Avoid new lines around the element to prevent extra spacing in the DOM.
  
    Args:
        url (str): url of the file this link will download.

    Returns:
        str: HTML of the download button.
    """
    return f"""<div class="download functional_button_container">
      <a download class="btn btn-secondary download_button" title="Download file" type="button" target="_blank" href="{ url }"><i class="fas fa-download"></i></a>
      </div>"""
---
# Discuss: Repurpose this for artifacts zip and possible future use with Scenario folders, etc?
need:
  - action_button_html
code: |
  def download_zip_button( url ):
    """
    Return the HTML to download a zip file.
  
    Avoid new lines around the element to prevent extra spacing in the DOM.
  
    Args:
        url (str): url of the zip this link will download.

    Returns:
        str: HTML of the download button.
    """
    return f"""<div class="download">
      <a download class="btn btn-secondary download_button" title="Download all" type="button" target="_blank" href="{ url }"><i class="fas fa-file-zipper"></i> Download all</a>
      </div>"""
---
need:
  - action_button_html
  - jumper_bottom_suffix
code: |
  def to_section_bottom_button( jump_down_prefix ):
    """
    Return HTML for a nav element that links to the bottom of a section.

    Avoid new lines around the element to prevent extra spacing in the DOM.

    Args:
        jump_down_prefix (str): A prefix for the href attribute that
          identifies the target at the section's bottom.

    Returns:
        str: HTML for the navigation element.
    """
    return f"""<nav class="jump jump_to_bottom_container functional_button_container">
        <a id="{ jump_down_prefix }_down_jumper" title="Go to the bottom of the section" class="jump_to_bottom btn btn-secondary" type="button" href="#{ jump_down_prefix }{ jumper_bottom_suffix }"><i class="fas fa-arrows-down-to-line"></i></a>
      </nav>"""
---
need:
  - action_button_html
  - jumper_bottom_suffix
code: |
  def to_section_top_button( jump_up_id ):
    """
    Return HTML for a nav element that links to the top of a section.

    Avoid new lines around the element to prevent extra spacing in the DOM.

    Args:
        jump_up_id (str): id of the target at the section's top.

    Returns:
        str: HTML for the navigation element.
    """
    return f"""
    <footer>
      <nav class="jump jump_to_top_container functional_button_container">
        <a id="{ jump_up_id }{ jumper_bottom_suffix }" title="Go to the top of the section" class="jump_to_top btn btn-secondary" type="button" href="#{ jump_up_id }"><i class="fas fa-arrows-up-to-line"></i></a>
      </nav>
    </footer>"""
---
id: jumper bottom html suffix to avoid future maintenance problems
code: |
  jumper_bottom_suffix = "_bottom"
---
# Misc
---
id: very strict name sanitization
code: |
  def very_safe_name( uncertain_str ):
    """
    Sanitize a string by replacing unsafe characters with underscores.

    Args:
        uncertain_str (str): Possibly unsafe input string.

    Returns:
        str: A string with only alphanumeric chars and underscores.
    """
    return re.sub(r"[^A-z0-9_]", "_", str( uncertain_str ))
---
---
id: check command existence
code: |
  import os
  def has_command( bin_name ):
    """
    Returns whether a command named by `bin_name` exists in this environment.

    Args:
        bin_name (str): Name of the command

    Returns:
        bool: True if the command exists. Otherwise False.
    """
    cmd_exists = os.path.isfile(f"/var/www/.npm-global/bin/{ bin_name }")
    return cmd_exists
---
---
code: |
  def _log( to_log, where="log" ):
    """
    Logs `to_log` to the desired location and the console.

    Args:
        to_log (str): Message to log.
        where (str): A valid 2nd argument to docassemble `log()`. Ex: 'console'
    """
    log( to_log, where )
    if where != "console":
      log( to_log, "console" )
    return ''
---
need:
  - debugging
code: |
  def _debug( to_log, where="log" ):
    """
    Logs the object representation or the string of `to_log` to the desired
        location and the console if the debug flag is on.

    Args:
        to_log (str): Value to log.
        where (str): A valid 2nd argument to docassemble `log()`. Ex: 'console'
    """
    if debugging == True or debugging == "true" or debugging == "True" or debugging == "TRUE" or debugging == "1":
      try:
        log( repr( to_log ), where )
        if where != "console":
          log( repr( to_log ), "console" )
      except:
        try:
          log( to_log, where )
          if where != "console":
            log( to_log, "console" )
        except:
          pass
    return ''
---
code: |
  debugging = alkiln_config_vars.get('alkip_debug', False) or alkiln_config_vars.get("alkiln_debug", False)
---
---
code: |
  docassemble_log_link = f"""<a target="_blank" href="{ url_of('root', _external=True) }/logs?file=docassemble.log">docassemble.log</a>"""
  
  worker_log_link = f"""<a target="_blank" href="{ url_of('root', _external=True) }/logs?file=worker.log">worker.log</a>"""
---
need:
  - docassemble_log_link
code: |
  da_log_more_info = f"Your { docassemble_log_link } might have more information."
---
need:
  - worker_log_link
code: |
  worker_log_more_info = f"Your { worker_log_link } might have more information."
---
need:
  - docassemble_log_link
  - worker_log_link
code: |
  logs_more_info = f"Your { docassemble_log_link } or { worker_log_link } might have more information."
---
---
code: |
  import time
  def timey():
    return time.time()
---
need:
  - root_path
  - alkiln_session_id
code: |
  kip_dir = f"{ root_path }/{ alkiln_session_id }"
---
need:
  - root_path
  - alkiln_session_id
  - kip_session_filename
code: |
  kip_vars_path = f"{ root_path }/{ alkiln_session_id }/{ kip_session_filename }"
---
id: id of this alkiln test run interview
need:
  - very_safe_name
  - timey
code: |
  alkiln_session_id = f"""alkiln_{ very_safe_name(timey()) }_{ current_context().session }"""
---
id: name of kip runtime vars
code: |
  kip_session_filename = "alkip_runtime.json"
---
# Default
code: |
  root_path = "/tmp"
---
